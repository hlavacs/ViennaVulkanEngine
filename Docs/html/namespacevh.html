<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vienna Vulkan Engine: vh Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vienna Vulkan Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vh Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvh_1_1_queue_family_indices.html">QueueFamilyIndices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">need only for start up  <a href="structvh_1_1_queue_family_indices.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvh_1_1_swap_chain_support_details.html">SwapChainSupportDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">need only for start up  <a href="structvh_1_1_swap_chain_support_details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvh_1_1vh_memory_block.html">vhMemoryBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A block of N entries, which are UBOs that e.g. define world matrices etc.  <a href="structvh_1_1vh_memory_block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvh_1_1vh_memory_handle.html">vhMemoryHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle into an entry of a memory block.  <a href="structvh_1_1vh_memory_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvh_1_1vh_vertex.html">vhVertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">per vertex data that is stored in the vertex buffers  <a href="structvh_1_1vh_vertex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1e453b74fd578311fb8164797d9f7e31"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a1e453b74fd578311fb8164797d9f7e31">vhBufCreateBuffer</a> (VmaAllocator allocator, VkDeviceSize size, VkBufferUsageFlags usage, VmaMemoryUsage vmaUsage, VkBuffer *buffer, VmaAllocation *allocation)</td></tr>
<tr class="memdesc:a1e453b74fd578311fb8164797d9f7e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Vulkan buffer.  <a href="#a1e453b74fd578311fb8164797d9f7e31">More...</a><br /></td></tr>
<tr class="separator:a1e453b74fd578311fb8164797d9f7e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacb884f1a1b7b7fdaef90231cd375fc"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#afacb884f1a1b7b7fdaef90231cd375fc">vhBufCopyBuffer</a> (VkDevice device, VkQueue graphicsQueue, VkCommandPool commandPool, VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size)</td></tr>
<tr class="memdesc:afacb884f1a1b7b7fdaef90231cd375fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a buffer from a source buffer to a destination buffer.  <a href="#afacb884f1a1b7b7fdaef90231cd375fc">More...</a><br /></td></tr>
<tr class="separator:afacb884f1a1b7b7fdaef90231cd375fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bbfc56732a182fe87f10ce967699ed"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ae5bbfc56732a182fe87f10ce967699ed">vhBufCreateImageView</a> (VkDevice device, VkImage image, VkFormat format, VkImageViewType viewtype, uint32_t layerCount, VkImageAspectFlags aspectFlags, VkImageView *imageView)</td></tr>
<tr class="memdesc:ae5bbfc56732a182fe87f10ce967699ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a view for a Vulkan image.  <a href="#ae5bbfc56732a182fe87f10ce967699ed">More...</a><br /></td></tr>
<tr class="separator:ae5bbfc56732a182fe87f10ce967699ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056517b52b39bf799c9e171209c05b46"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a056517b52b39bf799c9e171209c05b46">vhBufCreateDepthResources</a> (VkDevice device, VmaAllocator allocator, VkQueue graphicsQueue, VkCommandPool commandPool, VkExtent2D extent, VkFormat depthFormat, VkImage *depthImage, VmaAllocation *depthImageAllocation, VkImageView *depthImageView)</td></tr>
<tr class="memdesc:a056517b52b39bf799c9e171209c05b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a depth image and a view to be used as depth map.  <a href="#a056517b52b39bf799c9e171209c05b46">More...</a><br /></td></tr>
<tr class="separator:a056517b52b39bf799c9e171209c05b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b369467235917658b2b1e380bb5272"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a41b369467235917658b2b1e380bb5272">vhBufCreateImage</a> (VmaAllocator allocator, uint32_t width, uint32_t height, uint32_t miplevels, uint32_t arrayLayers, VkFormat format, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImage *image, VmaAllocation *allocation)</td></tr>
<tr class="memdesc:a41b369467235917658b2b1e380bb5272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Vulkan image using VMA.  <a href="#a41b369467235917658b2b1e380bb5272">More...</a><br /></td></tr>
<tr class="separator:a41b369467235917658b2b1e380bb5272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a765fa525c8857895ba358996a2938"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a77a765fa525c8857895ba358996a2938">hasStencilComponent</a> (VkFormat format)</td></tr>
<tr class="separator:a77a765fa525c8857895ba358996a2938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6013974401fbc5a20e71e57f81d03fd"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ad6013974401fbc5a20e71e57f81d03fd">vhBufCopyBufferToImage</a> (VkDevice device, VkQueue graphicsQueue, VkCommandPool commandPool, VkBuffer buffer, VkImage image, uint32_t layerCount, uint32_t width, uint32_t height)</td></tr>
<tr class="memdesc:ad6013974401fbc5a20e71e57f81d03fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a buffer to an image (for uploading via a staging buffer)  <a href="#ad6013974401fbc5a20e71e57f81d03fd">More...</a><br /></td></tr>
<tr class="separator:ad6013974401fbc5a20e71e57f81d03fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e21fd45374af2a124cbaf28e6f63c72"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a2e21fd45374af2a124cbaf28e6f63c72">vhBufCopyBufferToImage</a> (VkDevice device, VkQueue graphicsQueue, VkCommandPool commandPool, VkBuffer buffer, VkImage image, std::vector&lt; VkBufferImageCopy &gt; &amp;regions, uint32_t width, uint32_t height)</td></tr>
<tr class="memdesc:a2e21fd45374af2a124cbaf28e6f63c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for copying a buffer to an image, manages queue submission.  <a href="#a2e21fd45374af2a124cbaf28e6f63c72">More...</a><br /></td></tr>
<tr class="separator:a2e21fd45374af2a124cbaf28e6f63c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17813ab63ecaa73dcc45eb113e816fe"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ab17813ab63ecaa73dcc45eb113e816fe">vhBufCopyImageToBuffer</a> (VkDevice device, VkQueue graphicsQueue, VkCommandPool commandPool, VkImage image, VkImageAspectFlagBits aspect, VkBuffer buffer, uint32_t layerCount, uint32_t width, uint32_t height)</td></tr>
<tr class="memdesc:ab17813ab63ecaa73dcc45eb113e816fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a VKImage to a VKBuffer.  <a href="#ab17813ab63ecaa73dcc45eb113e816fe">More...</a><br /></td></tr>
<tr class="separator:ab17813ab63ecaa73dcc45eb113e816fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9dfd0d37a40cf2657779c996b0a138"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a7c9dfd0d37a40cf2657779c996b0a138">vhBufCopyImageToBuffer</a> (VkDevice device, VkQueue graphicsQueue, VkCommandPool commandPool, VkImage image, VkBuffer buffer, std::vector&lt; VkBufferImageCopy &gt; &amp;regions, uint32_t width, uint32_t height)</td></tr>
<tr class="memdesc:a7c9dfd0d37a40cf2657779c996b0a138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a VKImage to a VKBuffer.  <a href="#a7c9dfd0d37a40cf2657779c996b0a138">More...</a><br /></td></tr>
<tr class="separator:a7c9dfd0d37a40cf2657779c996b0a138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fb4550531664b62cf3a54d377515a7"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a06fb4550531664b62cf3a54d377515a7">vhBufTransitionImageLayout</a> (VkDevice device, VkQueue graphicsQueue, VkCommandPool commandPool, VkImage image, VkFormat format, VkImageAspectFlagBits aspect, uint32_t miplevels, uint32_t layerCount, VkImageLayout oldLayout, VkImageLayout newLayout)</td></tr>
<tr class="memdesc:a06fb4550531664b62cf3a54d377515a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition the image layout, causes a pipeline barrier.  <a href="#a06fb4550531664b62cf3a54d377515a7">More...</a><br /></td></tr>
<tr class="separator:a06fb4550531664b62cf3a54d377515a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb418fe457b4b3cde96e4499ba2e9e6"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a3bb418fe457b4b3cde96e4499ba2e9e6">vhBufTransitionImageLayout</a> (VkDevice device, VkQueue graphicsQueue, VkCommandBuffer commandBuffer, VkImage image, VkFormat format, VkImageAspectFlagBits aspect, uint32_t miplevels, uint32_t layerCount, VkImageLayout oldLayout, VkImageLayout newLayout)</td></tr>
<tr class="memdesc:a3bb418fe457b4b3cde96e4499ba2e9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition the image layout, causes a pipeline barrier.  <a href="#a3bb418fe457b4b3cde96e4499ba2e9e6">More...</a><br /></td></tr>
<tr class="separator:a3bb418fe457b4b3cde96e4499ba2e9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffbd8afe369bd26aada3c4935bbfded"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a9ffbd8afe369bd26aada3c4935bbfded">vhBufCreateTextureImage</a> (VkDevice device, VmaAllocator allocator, VkQueue graphicsQueue, VkCommandPool commandPool, std::string basedir, std::vector&lt; std::string &gt; texNames, VkImageCreateFlags flags, VkImage *textureImage, VmaAllocation *textureImageAllocation, VkExtent2D *extent)</td></tr>
<tr class="memdesc:a9ffbd8afe369bd26aada3c4935bbfded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a texture image from multiple files.  <a href="#a9ffbd8afe369bd26aada3c4935bbfded">More...</a><br /></td></tr>
<tr class="separator:a9ffbd8afe369bd26aada3c4935bbfded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf37e6299054ea7f5138aaa4e426ce72"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#acf37e6299054ea7f5138aaa4e426ce72">vhBufCreateTexturecubeImage</a> (VkDevice device, VmaAllocator allocator, VkQueue graphicsQueue, VkCommandPool commandPool, gli::texture_cube &amp;texCube, VkImage *textureImage, VmaAllocation *textureImageAllocation, VkFormat *pFormat)</td></tr>
<tr class="memdesc:acf37e6299054ea7f5138aaa4e426ce72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an image that is also a cubemap.  <a href="#acf37e6299054ea7f5138aaa4e426ce72">More...</a><br /></td></tr>
<tr class="separator:acf37e6299054ea7f5138aaa4e426ce72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6871f715a2f97378170122f36283079"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ab6871f715a2f97378170122f36283079">vhBufCreateTextureSampler</a> (VkDevice device, VkSampler *textureSampler)</td></tr>
<tr class="memdesc:ab6871f715a2f97378170122f36283079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an image sampler for samplign textures in shaders.  <a href="#ab6871f715a2f97378170122f36283079">More...</a><br /></td></tr>
<tr class="separator:ab6871f715a2f97378170122f36283079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47f3ffb11c9338fcf9421d8356e7935"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ab47f3ffb11c9338fcf9421d8356e7935">vhBufCreateFramebuffers</a> (VkDevice device, std::vector&lt; VkImageView &gt; imageViews, std::vector&lt; VkImageView &gt; depthImageViews, VkRenderPass renderPass, VkExtent2D extent, std::vector&lt; VkFramebuffer &gt; &amp;frameBuffers)</td></tr>
<tr class="memdesc:ab47f3ffb11c9338fcf9421d8356e7935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create framebuffers (color + depth), one for each swap chain image.  <a href="#ab47f3ffb11c9338fcf9421d8356e7935">More...</a><br /></td></tr>
<tr class="separator:ab47f3ffb11c9338fcf9421d8356e7935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5eba21d77f42e06cba84215d055f9b4"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ac5eba21d77f42e06cba84215d055f9b4">vhBufCopySwapChainImageToHost</a> (VkDevice device, VmaAllocator allocator, VkQueue graphicsQueue, VkCommandPool commandPool, VkImage image, VkFormat format, VkImageAspectFlagBits aspect, VkImageLayout layout, gli::byte *bufferData, uint32_t width, uint32_t height, uint32_t imageSize)</td></tr>
<tr class="memdesc:ac5eba21d77f42e06cba84215d055f9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a swap chain image to a data buffer, after it has been rendered into.  <a href="#ac5eba21d77f42e06cba84215d055f9b4">More...</a><br /></td></tr>
<tr class="separator:ac5eba21d77f42e06cba84215d055f9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8450c3d2289db3a176055b293847f7d"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#af8450c3d2289db3a176055b293847f7d">vhBufCopyImageToHost</a> (VkDevice device, VmaAllocator allocator, VkQueue graphicsQueue, VkCommandPool commandPool, VkImage image, VkFormat format, VkImageAspectFlagBits aspect, VkImageLayout layout, gli::byte *bufferData, uint32_t width, uint32_t height, uint32_t imageSize)</td></tr>
<tr class="memdesc:af8450c3d2289db3a176055b293847f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a swap chain image to a data buffer, after it has been rendered into.  <a href="#af8450c3d2289db3a176055b293847f7d">More...</a><br /></td></tr>
<tr class="separator:af8450c3d2289db3a176055b293847f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a49e59322f37fb65f61a23c1a6363cb"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a6a49e59322f37fb65f61a23c1a6363cb">vhBufCreateVertexBuffer</a> (VkDevice device, VmaAllocator allocator, VkQueue graphicsQueue, VkCommandPool commandPool, std::vector&lt; <a class="el" href="structvh_1_1vh_vertex.html">vh::vhVertex</a> &gt; &amp;vertices, VkBuffer *vertexBuffer, VmaAllocation *vertexBufferAllocation)</td></tr>
<tr class="memdesc:a6a49e59322f37fb65f61a23c1a6363cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Vulkan vertex buffer.  <a href="#a6a49e59322f37fb65f61a23c1a6363cb">More...</a><br /></td></tr>
<tr class="separator:a6a49e59322f37fb65f61a23c1a6363cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaaec135aa5e17e36607d4fa3e00d5a2"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#abaaec135aa5e17e36607d4fa3e00d5a2">vhBufCreateIndexBuffer</a> (VkDevice device, VmaAllocator allocator, VkQueue graphicsQueue, VkCommandPool commandPool, std::vector&lt; uint32_t &gt; &amp;indices, VkBuffer *indexBuffer, VmaAllocation *indexBufferAllocation)</td></tr>
<tr class="memdesc:abaaec135aa5e17e36607d4fa3e00d5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Vulkan index buffer.  <a href="#abaaec135aa5e17e36607d4fa3e00d5a2">More...</a><br /></td></tr>
<tr class="separator:abaaec135aa5e17e36607d4fa3e00d5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab714be58a365d2b553dea57cb4622b2d"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ab714be58a365d2b553dea57cb4622b2d">vhBufCreateUniformBuffers</a> (VmaAllocator allocator, uint32_t numberBuffers, VkDeviceSize bufferSize, std::vector&lt; VkBuffer &gt; &amp;uniformBuffers, std::vector&lt; VmaAllocation &gt; &amp;uniformBuffersAllocation)</td></tr>
<tr class="memdesc:ab714be58a365d2b553dea57cb4622b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a UBO.  <a href="#ab714be58a365d2b553dea57cb4622b2d">More...</a><br /></td></tr>
<tr class="separator:ab714be58a365d2b553dea57cb4622b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c523c56a5fe3a0bb7e3dd58a135d16"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ac6c523c56a5fe3a0bb7e3dd58a135d16">vhCmdCreateCommandPool</a> (VkPhysicalDevice physicalDevice, VkDevice device, VkSurfaceKHR surface, VkCommandPool *commandPool)</td></tr>
<tr class="memdesc:ac6c523c56a5fe3a0bb7e3dd58a135d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new command pool.  <a href="#ac6c523c56a5fe3a0bb7e3dd58a135d16">More...</a><br /></td></tr>
<tr class="separator:ac6c523c56a5fe3a0bb7e3dd58a135d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce4235cfc97c6ecc8ba9340ca99a3f9"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#afce4235cfc97c6ecc8ba9340ca99a3f9">vhCmdCreateCommandBuffers</a> (VkDevice device, VkCommandPool commandPool, VkCommandBufferLevel level, uint32_t count, VkCommandBuffer *pBuffers)</td></tr>
<tr class="memdesc:afce4235cfc97c6ecc8ba9340ca99a3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a number of command buffers.  <a href="#afce4235cfc97c6ecc8ba9340ca99a3f9">More...</a><br /></td></tr>
<tr class="separator:afce4235cfc97c6ecc8ba9340ca99a3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2562093b3408ae1d0849c59fff75440a"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a2562093b3408ae1d0849c59fff75440a">vhCmdBeginCommandBuffer</a> (VkDevice device, VkRenderPass renderPass, uint32_t subpass, VkFramebuffer frameBuffer, VkCommandBuffer commandBuffer, VkCommandBufferUsageFlagBits usageFlags)</td></tr>
<tr class="memdesc:a2562093b3408ae1d0849c59fff75440a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a command buffer for recording commands.  <a href="#a2562093b3408ae1d0849c59fff75440a">More...</a><br /></td></tr>
<tr class="separator:a2562093b3408ae1d0849c59fff75440a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9791b75aecc6358fa0be4612d8a83b95"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a9791b75aecc6358fa0be4612d8a83b95">vhCmdBeginCommandBuffer</a> (VkDevice device, VkCommandBuffer commandBuffer, VkCommandBufferUsageFlagBits usageFlags)</td></tr>
<tr class="memdesc:a9791b75aecc6358fa0be4612d8a83b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a command buffer for recording commands.  <a href="#a9791b75aecc6358fa0be4612d8a83b95">More...</a><br /></td></tr>
<tr class="separator:a9791b75aecc6358fa0be4612d8a83b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea5120b4ad57ec1f87cf053475bde19"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a9ea5120b4ad57ec1f87cf053475bde19">vhCmdSubmitCommandBuffer</a> (VkDevice device, VkQueue queue, VkCommandBuffer commandBuffer, VkSemaphore waitSemaphore, VkSemaphore signalSemaphore, VkFence waitFence)</td></tr>
<tr class="memdesc:a9ea5120b4ad57ec1f87cf053475bde19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a command buffer to a queue.  <a href="#a9ea5120b4ad57ec1f87cf053475bde19">More...</a><br /></td></tr>
<tr class="separator:a9ea5120b4ad57ec1f87cf053475bde19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b5d170d3b735ede6a6f57806402ad1"><td class="memItemLeft" align="right" valign="top">VkCommandBuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a72b5d170d3b735ede6a6f57806402ad1">vhCmdBeginSingleTimeCommands</a> (VkDevice device, VkCommandPool commandPool)</td></tr>
<tr class="memdesc:a72b5d170d3b735ede6a6f57806402ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin submitting a single time command.  <a href="#a72b5d170d3b735ede6a6f57806402ad1">More...</a><br /></td></tr>
<tr class="separator:a72b5d170d3b735ede6a6f57806402ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400527c7164faed90b5edac58203d4ba"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a400527c7164faed90b5edac58203d4ba">vhCmdEndSingleTimeCommands</a> (VkDevice device, VkQueue graphicsQueue, VkCommandPool commandPool, VkCommandBuffer commandBuffer)</td></tr>
<tr class="memdesc:a400527c7164faed90b5edac58203d4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">End recording into a single time command buffer and submit it.  <a href="#a400527c7164faed90b5edac58203d4ba">More...</a><br /></td></tr>
<tr class="separator:a400527c7164faed90b5edac58203d4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d980637f5b78d90e25253cba749e285"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a3d980637f5b78d90e25253cba749e285">vhCmdEndSingleTimeCommands</a> (VkDevice device, VkQueue graphicsQueue, VkCommandPool commandPool, VkCommandBuffer commandBuffer, VkSemaphore waitSemaphore, VkSemaphore signalSemaphore, VkFence waitFence)</td></tr>
<tr class="memdesc:a3d980637f5b78d90e25253cba749e285"><td class="mdescLeft">&#160;</td><td class="mdescRight">End recording into a single time command buffer and submit it.  <a href="#a3d980637f5b78d90e25253cba749e285">More...</a><br /></td></tr>
<tr class="separator:a3d980637f5b78d90e25253cba749e285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37cb47383e3f370dec52aec254a57b3"><td class="memItemLeft" align="right" valign="top"><a id="ad37cb47383e3f370dec52aec254a57b3"></a>
VKAPI_ATTR VkBool32 VKAPI_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ad37cb47383e3f370dec52aec254a57b3">vhDebugCallback</a> (VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objType, uint64_t obj, size_t location, int32_t code, const char *layerPrefix, const char *msg, void *userData)</td></tr>
<tr class="memdesc:ad37cb47383e3f370dec52aec254a57b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug callback. <br /></td></tr>
<tr class="separator:ad37cb47383e3f370dec52aec254a57b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6636471ca9dcc2d2c74c54f5f8ad39"><td class="memItemLeft" align="right" valign="top"><a id="aae6636471ca9dcc2d2c74c54f5f8ad39"></a>
VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#aae6636471ca9dcc2d2c74c54f5f8ad39">vhDebugCreateReportCallbackEXT</a> (VkInstance instance, const VkDebugReportCallbackCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugReportCallbackEXT *pCallback)</td></tr>
<tr class="memdesc:aae6636471ca9dcc2d2c74c54f5f8ad39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get debug callback function handle. <br /></td></tr>
<tr class="separator:aae6636471ca9dcc2d2c74c54f5f8ad39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6ae9a805291e72699e3eb99629f430"><td class="memItemLeft" align="right" valign="top"><a id="afd6ae9a805291e72699e3eb99629f430"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#afd6ae9a805291e72699e3eb99629f430">vhDebugDestroyReportCallbackEXT</a> (VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks *pAllocator)</td></tr>
<tr class="memdesc:afd6ae9a805291e72699e3eb99629f430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove debug callback. <br /></td></tr>
<tr class="separator:afd6ae9a805291e72699e3eb99629f430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdeb0d9fcda941f0cb92fd857002d309"><td class="memItemLeft" align="right" valign="top"><a id="abdeb0d9fcda941f0cb92fd857002d309"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#abdeb0d9fcda941f0cb92fd857002d309">vhSetupDebugCallback</a> (VkInstance instance, VkDebugReportCallbackEXT *callback)</td></tr>
<tr class="memdesc:abdeb0d9fcda941f0cb92fd857002d309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register debug callback. <br /></td></tr>
<tr class="separator:abdeb0d9fcda941f0cb92fd857002d309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42616af40e6817b748d42deeda488618"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a42616af40e6817b748d42deeda488618">checkValidationLayerSupport</a> (std::vector&lt; const char * &gt; &amp;validationLayers)</td></tr>
<tr class="memdesc:a42616af40e6817b748d42deeda488618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check validation layers of the Vulkan instance.  <a href="#a42616af40e6817b748d42deeda488618">More...</a><br /></td></tr>
<tr class="separator:a42616af40e6817b748d42deeda488618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451d818d1649c7341bbb892953716573"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a451d818d1649c7341bbb892953716573">vhDevCreateInstance</a> (std::vector&lt; const char * &gt; &amp;extensions, std::vector&lt; const char * &gt; &amp;validationLayers, VkInstance *instance)</td></tr>
<tr class="memdesc:a451d818d1649c7341bbb892953716573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Vulkan instance.  <a href="#a451d818d1649c7341bbb892953716573">More...</a><br /></td></tr>
<tr class="separator:a451d818d1649c7341bbb892953716573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3bbcd70fcf52ed6b19e0d72b75b2b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvh_1_1_queue_family_indices.html">QueueFamilyIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a8c3bbcd70fcf52ed6b19e0d72b75b2b4">vhDevFindQueueFamilies</a> (VkPhysicalDevice device, VkSurfaceKHR surface)</td></tr>
<tr class="memdesc:a8c3bbcd70fcf52ed6b19e0d72b75b2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find suitable queue families of a given physical device.  <a href="#a8c3bbcd70fcf52ed6b19e0d72b75b2b4">More...</a><br /></td></tr>
<tr class="separator:a8c3bbcd70fcf52ed6b19e0d72b75b2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8c854df58e16a79055422d1b1f8516"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a5b8c854df58e16a79055422d1b1f8516">checkDeviceExtensionSupport</a> (VkPhysicalDevice device, std::vector&lt; const char * &gt; requiredDeviceExtensions)</td></tr>
<tr class="memdesc:a5b8c854df58e16a79055422d1b1f8516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a given physical device offers a list of required extensions.  <a href="#a5b8c854df58e16a79055422d1b1f8516">More...</a><br /></td></tr>
<tr class="separator:a5b8c854df58e16a79055422d1b1f8516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70e43347ac845d3a98dd5a3ac36bf11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvh_1_1_swap_chain_support_details.html">SwapChainSupportDetails</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#af70e43347ac845d3a98dd5a3ac36bf11">vhDevQuerySwapChainSupport</a> (VkPhysicalDevice device, VkSurfaceKHR surface)</td></tr>
<tr class="memdesc:af70e43347ac845d3a98dd5a3ac36bf11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query which swap chains a physical device supports.  <a href="#af70e43347ac845d3a98dd5a3ac36bf11">More...</a><br /></td></tr>
<tr class="separator:af70e43347ac845d3a98dd5a3ac36bf11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c20b5524c517208b8984d3734f2aea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a57c20b5524c517208b8984d3734f2aea">isDeviceSuitable</a> (VkPhysicalDevice device, VkSurfaceKHR surface, std::vector&lt; const char * &gt; requiredDeviceExtensions)</td></tr>
<tr class="memdesc:a57c20b5524c517208b8984d3734f2aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether a physical offers all required extensions.  <a href="#a57c20b5524c517208b8984d3734f2aea">More...</a><br /></td></tr>
<tr class="separator:a57c20b5524c517208b8984d3734f2aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec90a175a6a85803cef70c3c41ce365f"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#aec90a175a6a85803cef70c3c41ce365f">vhDevPickPhysicalDevice</a> (VkInstance instance, VkSurfaceKHR surface, std::vector&lt; const char * &gt; requiredDeviceExtensions, VkPhysicalDevice *physicalDevice, VkPhysicalDeviceFeatures *pFeatures, VkPhysicalDeviceLimits *limits)</td></tr>
<tr class="memdesc:aec90a175a6a85803cef70c3c41ce365f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether a physical offers all required extensions.  <a href="#aec90a175a6a85803cef70c3c41ce365f">More...</a><br /></td></tr>
<tr class="separator:aec90a175a6a85803cef70c3c41ce365f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c685442b0d3f4a3dc89177f8d6f11b"><td class="memItemLeft" align="right" valign="top">VkFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a81c685442b0d3f4a3dc89177f8d6f11b">vhDevFindSupportedFormat</a> (VkPhysicalDevice physicalDevice, const std::vector&lt; VkFormat &gt; &amp;candidates, VkImageTiling tiling, VkFormatFeatureFlags features)</td></tr>
<tr class="memdesc:a81c685442b0d3f4a3dc89177f8d6f11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a suitable image format that the device supports.  <a href="#a81c685442b0d3f4a3dc89177f8d6f11b">More...</a><br /></td></tr>
<tr class="separator:a81c685442b0d3f4a3dc89177f8d6f11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c544f8c40f982eec87405acf83ce225"><td class="memItemLeft" align="right" valign="top">VkFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a8c544f8c40f982eec87405acf83ce225">vhDevFindDepthFormat</a> (VkPhysicalDevice physicalDevice)</td></tr>
<tr class="memdesc:a8c544f8c40f982eec87405acf83ce225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a suitable format for the depth/stencil buffer.  <a href="#a8c544f8c40f982eec87405acf83ce225">More...</a><br /></td></tr>
<tr class="separator:a8c544f8c40f982eec87405acf83ce225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef2251fdd3a8f216b82c9a16893578d"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#abef2251fdd3a8f216b82c9a16893578d">vhDevCreateLogicalDevice</a> (VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, std::vector&lt; const char * &gt; requiredDeviceExtensions, std::vector&lt; const char * &gt; requiredValidationLayers, VkDevice *device, VkQueue *graphicsQueue, VkQueue *presentQueue)</td></tr>
<tr class="memdesc:abef2251fdd3a8f216b82c9a16893578d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a logical device and according queues.  <a href="#abef2251fdd3a8f216b82c9a16893578d">More...</a><br /></td></tr>
<tr class="separator:abef2251fdd3a8f216b82c9a16893578d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1916a9160bee6b83f7f9effd3cdd34"><td class="memItemLeft" align="right" valign="top">std::vector&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a3e1916a9160bee6b83f7f9effd3cdd34">vhFileRead</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a3e1916a9160bee6b83f7f9effd3cdd34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the contents of a file and return a binary blob with it.  <a href="#a3e1916a9160bee6b83f7f9effd3cdd34">More...</a><br /></td></tr>
<tr class="separator:a3e1916a9160bee6b83f7f9effd3cdd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fad56183a7e4ab61241a8873a247ea1"><td class="memItemLeft" align="right" valign="top">std::chrono::high_resolution_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a4fad56183a7e4ab61241a8873a247ea1">vhTimeNow</a> ()</td></tr>
<tr class="memdesc:a4fad56183a7e4ab61241a8873a247ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a time measurment from the high resolution clock.  <a href="#a4fad56183a7e4ab61241a8873a247ea1">More...</a><br /></td></tr>
<tr class="separator:a4fad56183a7e4ab61241a8873a247ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19eaffd746fc8a31941d4559ca0894c0"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a19eaffd746fc8a31941d4559ca0894c0">vhTimeDuration</a> (std::chrono::high_resolution_clock::time_point t_prev)</td></tr>
<tr class="memdesc:a19eaffd746fc8a31941d4559ca0894c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the high resolution clock to calculate a time duration since the last time measurement.  <a href="#a19eaffd746fc8a31941d4559ca0894c0">More...</a><br /></td></tr>
<tr class="separator:a19eaffd746fc8a31941d4559ca0894c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2c15cc0cfeb131342076753df95788"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#adc2c15cc0cfeb131342076753df95788">vhAverage</a> (float new_val, float average, float weight)</td></tr>
<tr class="memdesc:adc2c15cc0cfeb131342076753df95788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply expoentatial smoothing to given values.  <a href="#adc2c15cc0cfeb131342076753df95788">More...</a><br /></td></tr>
<tr class="separator:adc2c15cc0cfeb131342076753df95788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0e56b8ed7309e0ebf5ba969323e4db"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a6d0e56b8ed7309e0ebf5ba969323e4db">vhSwapCreateSwapChain</a> (VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkDevice device, VkExtent2D frameBufferExtent, VkSwapchainKHR *swapChain, std::vector&lt; VkImage &gt; &amp;swapChainImages, std::vector&lt; VkImageView &gt; &amp;swapChainImageViews, VkFormat *swapChainImageFormat, VkExtent2D *swapChainExtent)</td></tr>
<tr class="memdesc:a6d0e56b8ed7309e0ebf5ba969323e4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose the swapchain.  <a href="#a6d0e56b8ed7309e0ebf5ba969323e4db">More...</a><br /></td></tr>
<tr class="separator:a6d0e56b8ed7309e0ebf5ba969323e4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf05b4e0ad73129da84053e0b354c9e"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#aebf05b4e0ad73129da84053e0b354c9e">vhRenderCreateRenderPass</a> (VkDevice device, VkFormat swapChainImageFormat, VkFormat depthFormat, VkAttachmentLoadOp loadOp, VkRenderPass *renderPass)</td></tr>
<tr class="memdesc:aebf05b4e0ad73129da84053e0b354c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a render pass for a light pass.  <a href="#aebf05b4e0ad73129da84053e0b354c9e">More...</a><br /></td></tr>
<tr class="separator:aebf05b4e0ad73129da84053e0b354c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb40be113bdc3486e32a2553561a279"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#abfb40be113bdc3486e32a2553561a279">vhRenderCreateRenderPassShadow</a> (VkDevice device, VkFormat depthFormat, VkRenderPass *renderPass)</td></tr>
<tr class="memdesc:abfb40be113bdc3486e32a2553561a279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a render pass for a shadow pass.  <a href="#abfb40be113bdc3486e32a2553561a279">More...</a><br /></td></tr>
<tr class="separator:abfb40be113bdc3486e32a2553561a279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace68f67085dba10e4361d22dc099efe6"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ace68f67085dba10e4361d22dc099efe6">vhRenderCreateDescriptorSetLayout</a> (VkDevice device, std::vector&lt; uint32_t &gt; counts, std::vector&lt; VkDescriptorType &gt; types, std::vector&lt; VkShaderStageFlags &gt; stageFlags, VkDescriptorSetLayout *descriptorSetLayout)</td></tr>
<tr class="memdesc:ace68f67085dba10e4361d22dc099efe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a descriptor layout.  <a href="#ace68f67085dba10e4361d22dc099efe6">More...</a><br /></td></tr>
<tr class="separator:ace68f67085dba10e4361d22dc099efe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9392ff3d54398fa4297a442ba2a0efb9"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a9392ff3d54398fa4297a442ba2a0efb9">vhRenderCreateDescriptorPool</a> (VkDevice device, std::vector&lt; VkDescriptorType &gt; types, std::vector&lt; uint32_t &gt; numberDesc, VkDescriptorPool *descriptorPool)</td></tr>
<tr class="memdesc:a9392ff3d54398fa4297a442ba2a0efb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a descriptor pool.  <a href="#a9392ff3d54398fa4297a442ba2a0efb9">More...</a><br /></td></tr>
<tr class="separator:a9392ff3d54398fa4297a442ba2a0efb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e15c0ed7b15c786bc1bc9f6a574c350"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a2e15c0ed7b15c786bc1bc9f6a574c350">vhRenderCreateDescriptorSets</a> (VkDevice device, uint32_t numberDesc, VkDescriptorSetLayout descriptorSetLayout, VkDescriptorPool descriptorPool, std::vector&lt; VkDescriptorSet &gt; &amp;descriptorSets)</td></tr>
<tr class="memdesc:a2e15c0ed7b15c786bc1bc9f6a574c350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a number of descriptor sets, one for each frame in the swapchain.  <a href="#a2e15c0ed7b15c786bc1bc9f6a574c350">More...</a><br /></td></tr>
<tr class="separator:a2e15c0ed7b15c786bc1bc9f6a574c350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686da75542975aa5930179c54bc17306"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a686da75542975aa5930179c54bc17306">vhRenderUpdateDescriptorSet</a> (VkDevice device, VkDescriptorSet descriptorSet, std::vector&lt; VkBuffer &gt; uniformBuffers, std::vector&lt; uint32_t &gt; bufferRanges, std::vector&lt; std::vector&lt; VkImageView &gt;&gt; textureImageViews, std::vector&lt; std::vector&lt; VkSampler &gt;&gt; textureSamplers)</td></tr>
<tr class="memdesc:a686da75542975aa5930179c54bc17306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a descriptor set.  <a href="#a686da75542975aa5930179c54bc17306">More...</a><br /></td></tr>
<tr class="separator:a686da75542975aa5930179c54bc17306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab6a4f31575479f0449c03cff83a3c0"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#afab6a4f31575479f0449c03cff83a3c0">vhRenderUpdateDescriptorSet</a> (VkDevice device, VkDescriptorSet descriptorSet, std::vector&lt; VkDescriptorType &gt; descriptorTypes, std::vector&lt; VkBuffer &gt; uniformBuffers, std::vector&lt; uint32_t &gt; bufferRanges, std::vector&lt; std::vector&lt; VkImageView &gt;&gt; textureImageViews, std::vector&lt; std::vector&lt; VkSampler &gt;&gt; textureSamplers)</td></tr>
<tr class="memdesc:afab6a4f31575479f0449c03cff83a3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a descriptor set.  <a href="#afab6a4f31575479f0449c03cff83a3c0">More...</a><br /></td></tr>
<tr class="separator:afab6a4f31575479f0449c03cff83a3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869d9fac1760fdf3ca8b7abcc2c143e9"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a869d9fac1760fdf3ca8b7abcc2c143e9">vhRenderUpdateDescriptorSetMaps</a> (VkDevice device, VkDescriptorSet descriptorSet, uint32_t binding, uint32_t offset, uint32_t descriptorCount, std::vector&lt; std::vector&lt; VkDescriptorImageInfo &gt;&gt; &amp;maps)</td></tr>
<tr class="memdesc:a869d9fac1760fdf3ca8b7abcc2c143e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a descriptor set being composed of arrays of textures.  <a href="#a869d9fac1760fdf3ca8b7abcc2c143e9">More...</a><br /></td></tr>
<tr class="separator:a869d9fac1760fdf3ca8b7abcc2c143e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe67797af87d26e35dc90d6432a3168"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#afbe67797af87d26e35dc90d6432a3168">vhRenderBeginRenderPass</a> (VkCommandBuffer commandBuffer, VkRenderPass renderPass, VkFramebuffer frameBuffer, VkExtent2D extent, VkSubpassContents subPassContents)</td></tr>
<tr class="memdesc:afbe67797af87d26e35dc90d6432a3168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start rendering in a command buffer.  <a href="#afbe67797af87d26e35dc90d6432a3168">More...</a><br /></td></tr>
<tr class="separator:afbe67797af87d26e35dc90d6432a3168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47e43e06e94906f31442d1546a6d3a7"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ae47e43e06e94906f31442d1546a6d3a7">vhRenderBeginRenderPass</a> (VkCommandBuffer commandBuffer, VkRenderPass renderPass, VkFramebuffer frameBuffer, std::vector&lt; VkClearValue &gt; &amp;clearValues, VkExtent2D extent, VkSubpassContents subPassContents)</td></tr>
<tr class="memdesc:ae47e43e06e94906f31442d1546a6d3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start rendering in a command buffer.  <a href="#ae47e43e06e94906f31442d1546a6d3a7">More...</a><br /></td></tr>
<tr class="separator:ae47e43e06e94906f31442d1546a6d3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4390e33b2435fdbf76124fdafe6fba2a"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a4390e33b2435fdbf76124fdafe6fba2a">vhRenderPresentResult</a> (VkQueue presentQueue, VkSwapchainKHR swapChain, uint32_t imageIndex, VkSemaphore signalSemaphore)</td></tr>
<tr class="memdesc:a4390e33b2435fdbf76124fdafe6fba2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Present the result of a render operation to a window.  <a href="#a4390e33b2435fdbf76124fdafe6fba2a">More...</a><br /></td></tr>
<tr class="separator:a4390e33b2435fdbf76124fdafe6fba2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7ac38cec91ccc1cb7f7fc295735651"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#add7ac38cec91ccc1cb7f7fc295735651">vhPipeCreateGraphicsPipelineLayout</a> (VkDevice device, std::vector&lt; VkDescriptorSetLayout &gt; descriptorSetLayouts, std::vector&lt; VkPushConstantRange &gt; pushConstantRanges, VkPipelineLayout *pipelineLayout)</td></tr>
<tr class="memdesc:add7ac38cec91ccc1cb7f7fc295735651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pipeline layout for drawing a light pass.  <a href="#add7ac38cec91ccc1cb7f7fc295735651">More...</a><br /></td></tr>
<tr class="separator:add7ac38cec91ccc1cb7f7fc295735651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7b7ff0f821ebef5c91f82314ddd7da"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a1a7b7ff0f821ebef5c91f82314ddd7da">vhPipeCreateGraphicsPipeline</a> (VkDevice device, std::vector&lt; std::string &gt; shaderFileNames, VkExtent2D swapChainExtent, VkPipelineLayout pipelineLayout, VkRenderPass renderPass, std::vector&lt; VkDynamicState &gt; dynamicStates, VkPipeline *graphicsPipeline)</td></tr>
<tr class="memdesc:a1a7b7ff0f821ebef5c91f82314ddd7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pipeline state object (PSO) for a light pass.  <a href="#a1a7b7ff0f821ebef5c91f82314ddd7da">More...</a><br /></td></tr>
<tr class="separator:a1a7b7ff0f821ebef5c91f82314ddd7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abe327f01dff0d2f8af18263ee4b768"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a0abe327f01dff0d2f8af18263ee4b768">vhPipeCreateGraphicsShadowPipeline</a> (VkDevice device, std::string verShaderFilename, VkExtent2D shadowMapExtent, VkPipelineLayout pipelineLayout, VkRenderPass renderPass, VkPipeline *graphicsPipeline)</td></tr>
<tr class="memdesc:a0abe327f01dff0d2f8af18263ee4b768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pipeline state object (PSO) for a shadow pass.  <a href="#a0abe327f01dff0d2f8af18263ee4b768">More...</a><br /></td></tr>
<tr class="separator:a0abe327f01dff0d2f8af18263ee4b768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f76d8d8eeb5c06b7f55273a79d9830d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a5f76d8d8eeb5c06b7f55273a79d9830d">vhMemFindMemoryType</a> (VkPhysicalDevice physicalDevice, uint32_t typeFilter, VkMemoryPropertyFlags properties)</td></tr>
<tr class="memdesc:a5f76d8d8eeb5c06b7f55273a79d9830d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the right memory type.  <a href="#a5f76d8d8eeb5c06b7f55273a79d9830d">More...</a><br /></td></tr>
<tr class="separator:a5f76d8d8eeb5c06b7f55273a79d9830d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7973d81d63d37347572c19477529dd7f"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a7973d81d63d37347572c19477529dd7f">vhMemCreateVMAAllocator</a> (VkPhysicalDevice physicalDevice, VkDevice device, VmaAllocator &amp;allocator)</td></tr>
<tr class="memdesc:a7973d81d63d37347572c19477529dd7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the VMA allocator library.  <a href="#a7973d81d63d37347572c19477529dd7f">More...</a><br /></td></tr>
<tr class="separator:a7973d81d63d37347572c19477529dd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201d7925aad9bb6685ceba7d73285d40"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a201d7925aad9bb6685ceba7d73285d40">vhMemBlockListInit</a> (VkDevice device, VmaAllocator allocator, VkDescriptorPool descriptorPool, VkDescriptorSetLayout descriptorLayout, uint32_t maxNumEntries, uint32_t sizeEntry, uint32_t numBuffers, std::vector&lt; <a class="el" href="structvh_1_1vh_memory_block.html">vhMemoryBlock</a> * &gt; &amp;blocklist)</td></tr>
<tr class="memdesc:a201d7925aad9bb6685ceba7d73285d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a list of memory blocks.  <a href="#a201d7925aad9bb6685ceba7d73285d40">More...</a><br /></td></tr>
<tr class="separator:a201d7925aad9bb6685ceba7d73285d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24b12561d007b25ffc99ab0a990d813"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ab24b12561d007b25ffc99ab0a990d813">vhMemBlockInit</a> (VkDevice device, VmaAllocator allocator, VkDescriptorPool descriptorPool, VkDescriptorSetLayout descriptorLayout, uint32_t maxNumEntries, uint32_t sizeEntry, uint32_t numBuffers, <a class="el" href="structvh_1_1vh_memory_block.html">vhMemoryBlock</a> *pBlock)</td></tr>
<tr class="memdesc:ab24b12561d007b25ffc99ab0a990d813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a single memory block.  <a href="#ab24b12561d007b25ffc99ab0a990d813">More...</a><br /></td></tr>
<tr class="separator:ab24b12561d007b25ffc99ab0a990d813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ca7c6b6a5a41f490eb3399590d4b7a"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#aa2ca7c6b6a5a41f490eb3399590d4b7a">vhMemBlockListAdd</a> (std::vector&lt; <a class="el" href="structvh_1_1vh_memory_block.html">vhMemoryBlock</a> * &gt; &amp;blocklist, void *owner, <a class="el" href="structvh_1_1vh_memory_handle.html">vhMemoryHandle</a> *handle)</td></tr>
<tr class="memdesc:aa2ca7c6b6a5a41f490eb3399590d4b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an entry to a memory block list.  <a href="#aa2ca7c6b6a5a41f490eb3399590d4b7a">More...</a><br /></td></tr>
<tr class="separator:aa2ca7c6b6a5a41f490eb3399590d4b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0423ae2bd016c8eb50c1750059e811c3"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a0423ae2bd016c8eb50c1750059e811c3">vhMemBlockAdd</a> (<a class="el" href="structvh_1_1vh_memory_block.html">vhMemoryBlock</a> *pBlock, void *owner, <a class="el" href="structvh_1_1vh_memory_handle.html">vhMemoryHandle</a> *handle)</td></tr>
<tr class="memdesc:a0423ae2bd016c8eb50c1750059e811c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an entry to a memory block (not a block list)  <a href="#a0423ae2bd016c8eb50c1750059e811c3">More...</a><br /></td></tr>
<tr class="separator:a0423ae2bd016c8eb50c1750059e811c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a86b5a941fb7fe31e3b10e9777461c"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a05a86b5a941fb7fe31e3b10e9777461c">vhMemBlockUpdateEntry</a> (<a class="el" href="structvh_1_1vh_memory_handle.html">vhMemoryHandle</a> *pHandle, void *data)</td></tr>
<tr class="memdesc:a05a86b5a941fb7fe31e3b10e9777461c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update an entry in one of the memory blocks.  <a href="#a05a86b5a941fb7fe31e3b10e9777461c">More...</a><br /></td></tr>
<tr class="separator:a05a86b5a941fb7fe31e3b10e9777461c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b1662591a2f820b12a485a17a8f2a0"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a83b1662591a2f820b12a485a17a8f2a0">vhMemBlockUpdateBlockList</a> (std::vector&lt; <a class="el" href="structvh_1_1vh_memory_block.html">vhMemoryBlock</a> * &gt; &amp;blocklist, uint32_t index)</td></tr>
<tr class="memdesc:a83b1662591a2f820b12a485a17a8f2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update all memory blocks by copying them to the GPU.  <a href="#a83b1662591a2f820b12a485a17a8f2a0">More...</a><br /></td></tr>
<tr class="separator:a83b1662591a2f820b12a485a17a8f2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eabede71703c653a56339072b352162"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a5eabede71703c653a56339072b352162">vhMemBlockRemoveEntry</a> (<a class="el" href="structvh_1_1vh_memory_handle.html">vhMemoryHandle</a> *pHandle)</td></tr>
<tr class="memdesc:a5eabede71703c653a56339072b352162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an entry from a memory block.  <a href="#a5eabede71703c653a56339072b352162">More...</a><br /></td></tr>
<tr class="separator:a5eabede71703c653a56339072b352162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106c314c7a88deb8050948301ea30012"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a106c314c7a88deb8050948301ea30012">vhMemBlockListClear</a> (std::vector&lt; <a class="el" href="structvh_1_1vh_memory_block.html">vhMemoryBlock</a> * &gt; &amp;blocklist)</td></tr>
<tr class="memdesc:a106c314c7a88deb8050948301ea30012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all entries and all blocks from a block list.  <a href="#a106c314c7a88deb8050948301ea30012">More...</a><br /></td></tr>
<tr class="separator:a106c314c7a88deb8050948301ea30012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416256074e592e0204883ac3e3d2361b"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a416256074e592e0204883ac3e3d2361b">vhMemBlockDeallocate</a> (<a class="el" href="structvh_1_1vh_memory_block.html">vhMemoryBlock</a> *pBlock)</td></tr>
<tr class="memdesc:a416256074e592e0204883ac3e3d2361b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate the memory from a block.  <a href="#a416256074e592e0204883ac3e3d2361b">More...</a><br /></td></tr>
<tr class="separator:a416256074e592e0204883ac3e3d2361b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613fe5f8bf3159e698b7188fdc5e39a1"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a613fe5f8bf3159e698b7188fdc5e39a1">vhMemBlockMoveEntry</a> (std::vector&lt; <a class="el" href="structvh_1_1vh_memory_block.html">vhMemoryBlock</a> * &gt; &amp;dstblocklist, <a class="el" href="structvh_1_1vh_memory_handle.html">vhMemoryHandle</a> *pHandle)</td></tr>
<tr class="memdesc:a613fe5f8bf3159e698b7188fdc5e39a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a handle from one list to another list.  <a href="#a613fe5f8bf3159e698b7188fdc5e39a1">More...</a><br /></td></tr>
<tr class="separator:a613fe5f8bf3159e698b7188fdc5e39a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7579b97116c0e15eecd4bd0ede9dea08"><td class="memItemLeft" align="right" valign="top">VkShaderModule&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a7579b97116c0e15eecd4bd0ede9dea08">vhPipeCreateShaderModule</a> (VkDevice device, const std::vector&lt; char &gt; &amp;code)</td></tr>
<tr class="memdesc:a7579b97116c0e15eecd4bd0ede9dea08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shader module.  <a href="#a7579b97116c0e15eecd4bd0ede9dea08">More...</a><br /></td></tr>
<tr class="separator:a7579b97116c0e15eecd4bd0ede9dea08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8becfa0316ca45ac8a219ce069aec09"><td class="memItemLeft" align="right" valign="top">VkSurfaceFormatKHR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ab8becfa0316ca45ac8a219ce069aec09">chooseSwapSurfaceFormat</a> (const std::vector&lt; VkSurfaceFormatKHR &gt; &amp;availableFormats)</td></tr>
<tr class="memdesc:ab8becfa0316ca45ac8a219ce069aec09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose swapchain format - try to use VK_FORMAT_B8G8R8A8_UNORM.  <a href="#ab8becfa0316ca45ac8a219ce069aec09">More...</a><br /></td></tr>
<tr class="separator:ab8becfa0316ca45ac8a219ce069aec09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fb86cff54a572754a511f5b3589c03"><td class="memItemLeft" align="right" valign="top">VkPresentModeKHR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ac2fb86cff54a572754a511f5b3589c03">chooseSwapPresentMode</a> (const std::vector&lt; VkPresentModeKHR &gt; availablePresentModes)</td></tr>
<tr class="memdesc:ac2fb86cff54a572754a511f5b3589c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose the swapchain present mode - try to use Mailbox.  <a href="#ac2fb86cff54a572754a511f5b3589c03">More...</a><br /></td></tr>
<tr class="separator:ac2fb86cff54a572754a511f5b3589c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13205b72a90888bd5950d79fcbd529b6"><td class="memItemLeft" align="right" valign="top">VkExtent2D&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a13205b72a90888bd5950d79fcbd529b6">chooseSwapExtent</a> (const VkSurfaceCapabilitiesKHR &amp;capabilities, VkExtent2D extent)</td></tr>
<tr class="memdesc:a13205b72a90888bd5950d79fcbd529b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose the 2D extent of the swapchain.  <a href="#a13205b72a90888bd5950d79fcbd529b6">More...</a><br /></td></tr>
<tr class="separator:a13205b72a90888bd5950d79fcbd529b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Vienna Vulkan Engine</p>
<p>(c) bei Helmut Hlavacs, University of Vienna </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a5b8c854df58e16a79055422d1b1f8516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8c854df58e16a79055422d1b1f8516">&#9670;&nbsp;</a></span>checkDeviceExtensionSupport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vh::checkDeviceExtensionSupport </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const char * &gt;&#160;</td>
          <td class="paramname"><em>requiredDeviceExtensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a given physical device offers a list of required extensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>A physical device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">requiredDeviceExtensions</td><td>A list with required device extensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the device supports all extensions or not </dd></dl>

</div>
</div>
<a id="a42616af40e6817b748d42deeda488618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42616af40e6817b748d42deeda488618">&#9670;&nbsp;</a></span>checkValidationLayerSupport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vh::checkValidationLayerSupport </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const char * &gt; &amp;&#160;</td>
          <td class="paramname"><em>validationLayers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check validation layers of the Vulkan instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">validationLayers</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all requested layers are supported by the device, else false </dd></dl>

</div>
</div>
<a id="a13205b72a90888bd5950d79fcbd529b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13205b72a90888bd5950d79fcbd529b6">&#9670;&nbsp;</a></span>chooseSwapExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkExtent2D vh::chooseSwapExtent </td>
          <td>(</td>
          <td class="paramtype">const VkSurfaceCapabilitiesKHR &amp;&#160;</td>
          <td class="paramname"><em>capabilities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkExtent2D&#160;</td>
          <td class="paramname"><em>extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose the 2D extent of the swapchain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capabilities</td><td>Capabilities of the window surface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extent</td><td>Extent of the window </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the chosen swapchain extent </dd></dl>

</div>
</div>
<a id="ac2fb86cff54a572754a511f5b3589c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fb86cff54a572754a511f5b3589c03">&#9670;&nbsp;</a></span>chooseSwapPresentMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkPresentModeKHR vh::chooseSwapPresentMode </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; VkPresentModeKHR &gt;&#160;</td>
          <td class="paramname"><em>availablePresentModes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose the swapchain present mode - try to use Mailbox. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">availablePresentModes</td><td>A list of available swap chain present modes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the chosen swapchain format </dd></dl>

</div>
</div>
<a id="ab8becfa0316ca45ac8a219ce069aec09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8becfa0316ca45ac8a219ce069aec09">&#9670;&nbsp;</a></span>chooseSwapSurfaceFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkSurfaceFormatKHR vh::chooseSwapSurfaceFormat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; VkSurfaceFormatKHR &gt; &amp;&#160;</td>
          <td class="paramname"><em>availableFormats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose swapchain format - try to use VK_FORMAT_B8G8R8A8_UNORM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">availableFormats</td><td>A list of available swap chain formats </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the chosen swapchain format </dd></dl>

</div>
</div>
<a id="a77a765fa525c8857895ba358996a2938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a765fa525c8857895ba358996a2938">&#9670;&nbsp;</a></span>hasStencilComponent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vh::hasStencilComponent </td>
          <td>(</td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether a depth image format supports stencil information </dd></dl>

</div>
</div>
<a id="a57c20b5524c517208b8984d3734f2aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c20b5524c517208b8984d3734f2aea">&#9670;&nbsp;</a></span>isDeviceSuitable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vh::isDeviceSuitable </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSurfaceKHR&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const char * &gt;&#160;</td>
          <td class="paramname"><em>requiredDeviceExtensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether a physical offers all required extensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>A physical device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surface</td><td>A window surface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">requiredDeviceExtensions</td><td>A list of required device extensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the device supports all required extensions or not </dd></dl>

</div>
</div>
<a id="adc2c15cc0cfeb131342076753df95788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2c15cc0cfeb131342076753df95788">&#9670;&nbsp;</a></span>vhAverage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float vh::vhAverage </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>new_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>average</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply expoentatial smoothing to given values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_val</td><td>The newest value that was measured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">average</td><td>The average so far </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>An averaging weight between 0 and 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new average </dd></dl>

</div>
</div>
<a id="afacb884f1a1b7b7fdaef90231cd375fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afacb884f1a1b7b7fdaef90231cd375fc">&#9670;&nbsp;</a></span>vhBufCopyBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhBufCopyBuffer </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>srcBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a buffer from a source buffer to a destination buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command bbuffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBuffer</td><td>Source buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstBuffer</td><td>Destination buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size in bytes of the data to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="ad6013974401fbc5a20e71e57f81d03fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6013974401fbc5a20e71e57f81d03fd">&#9670;&nbsp;</a></span>vhBufCopyBufferToImage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhBufCopyBufferToImage </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a buffer to an image (for uploading via a staging buffer) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command buffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The source buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The destination image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layerCount</td><td>Number of layers in the image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Image width </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Image height </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a2e21fd45374af2a124cbaf28e6f63c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e21fd45374af2a124cbaf28e6f63c72">&#9670;&nbsp;</a></span>vhBufCopyBufferToImage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhBufCopyBufferToImage </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkBufferImageCopy &gt; &amp;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for copying a buffer to an image, manages queue submission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command buffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The source buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The destination image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regions</td><td>The regions to be copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width of the image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Height of the image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="ab17813ab63ecaa73dcc45eb113e816fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17813ab63ecaa73dcc45eb113e816fe">&#9670;&nbsp;</a></span>vhBufCopyImageToBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhBufCopyImageToBuffer </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageAspectFlagBits&#160;</td>
          <td class="paramname"><em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a VKImage to a VKBuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command buffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The source image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aspect</td><td>Aspect on how to use the image (color or depth) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The destination buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layerCount</td><td>Number of image layers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>mage width </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Image height </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a7c9dfd0d37a40cf2657779c996b0a138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9dfd0d37a40cf2657779c996b0a138">&#9670;&nbsp;</a></span>vhBufCopyImageToBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhBufCopyImageToBuffer </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkBufferImageCopy &gt; &amp;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a VKImage to a VKBuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command buffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The source image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The destination buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regions</td><td>Copy regions detailing the image parts that should be copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>mage width </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Image height </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="af8450c3d2289db3a176055b293847f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8450c3d2289db3a176055b293847f7d">&#9670;&nbsp;</a></span>vhBufCopyImageToHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhBufCopyImageToHost </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocator&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageAspectFlagBits&#160;</td>
          <td class="paramname"><em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gli::byte *&#160;</td>
          <td class="paramname"><em>bufferData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>imageSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a swap chain image to a data buffer, after it has been rendered into. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>VMA allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command buffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The source image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format of the image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aspect</td><td>Color or depth </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>The layout the image is currently in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferData</td><td>The destination buffer data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>mage width </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Image height </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imageSize</td><td>Size of the image in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="ac5eba21d77f42e06cba84215d055f9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5eba21d77f42e06cba84215d055f9b4">&#9670;&nbsp;</a></span>vhBufCopySwapChainImageToHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhBufCopySwapChainImageToHost </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocator&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageAspectFlagBits&#160;</td>
          <td class="paramname"><em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gli::byte *&#160;</td>
          <td class="paramname"><em>bufferData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>imageSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a swap chain image to a data buffer, after it has been rendered into. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>VMA allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command buffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The source image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>The pixel format of this image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aspect</td><td>Color or depth </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>The layout that this image is currently and should be again after the copy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferData</td><td>The destination buffer data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>mage width </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Image height </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imageSize</td><td>Size of the image in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a1e453b74fd578311fb8164797d9f7e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e453b74fd578311fb8164797d9f7e31">&#9670;&nbsp;</a></span>vhBufCreateBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhBufCreateBuffer </td>
          <td>(</td>
          <td class="paramtype">VmaAllocator&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBufferUsageFlags&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaMemoryUsage&#160;</td>
          <td class="paramname"><em>vmaUsage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocation *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Vulkan buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>VMA allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the buffer in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usage</td><td>Buffer usage flags </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vmaUsage</td><td>Usage for VMA </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The created buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allocation</td><td>The VMA allocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a056517b52b39bf799c9e171209c05b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056517b52b39bf799c9e171209c05b46">&#9670;&nbsp;</a></span>vhBufCreateDepthResources()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhBufCreateDepthResources </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocator&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkExtent2D&#160;</td>
          <td class="paramname"><em>extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>depthFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage *&#160;</td>
          <td class="paramname"><em>depthImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocation *&#160;</td>
          <td class="paramname"><em>depthImageAllocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageView *&#160;</td>
          <td class="paramname"><em>depthImageView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a depth image and a view to be used as depth map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>VMA allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command bbuffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extent</td><td>Extent of the swap chain images </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">depthFormat</td><td>Depth image format to be used for depth map </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">depthImage</td><td>Depth image to be used as depth map </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">depthImageAllocation</td><td>VMA allocation info </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">depthImageView</td><td>View of the depth image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="ab47f3ffb11c9338fcf9421d8356e7935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47f3ffb11c9338fcf9421d8356e7935">&#9670;&nbsp;</a></span>vhBufCreateFramebuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhBufCreateFramebuffers </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkImageView &gt;&#160;</td>
          <td class="paramname"><em>imageViews</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkImageView &gt;&#160;</td>
          <td class="paramname"><em>depthImageViews</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkRenderPass&#160;</td>
          <td class="paramname"><em>renderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkExtent2D&#160;</td>
          <td class="paramname"><em>extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkFramebuffer &gt; &amp;&#160;</td>
          <td class="paramname"><em>frameBuffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create framebuffers (color + depth), one for each swap chain image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imageViews</td><td>Color images from the swap chain </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depthImageViews</td><td>List with views of the depth images </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">renderPass</td><td>Render pass to be used in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extent</td><td>Extent of the swap chain images </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">frameBuffers</td><td>The resulting frame buffers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a41b369467235917658b2b1e380bb5272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b369467235917658b2b1e380bb5272">&#9670;&nbsp;</a></span>vhBufCreateImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhBufCreateImage </td>
          <td>(</td>
          <td class="paramtype">VmaAllocator&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>miplevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageTiling&#160;</td>
          <td class="paramname"><em>tiling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageUsageFlags&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageCreateFlags&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocation *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Vulkan image using VMA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Th VMA allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width of the image to be created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Height of the image to be created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">miplevels</td><td>Number of miplevels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayLayers</td><td>Number of image layers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Image format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tiling</td><td>Ho to layout the image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usage</td><td>Usage flags </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Create flags </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">image</td><td>The new image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allocation</td><td>VMA allocation information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="ae5bbfc56732a182fe87f10ce967699ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bbfc56732a182fe87f10ce967699ed">&#9670;&nbsp;</a></span>vhBufCreateImageView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhBufCreateImageView </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageViewType&#160;</td>
          <td class="paramname"><em>viewtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageAspectFlags&#160;</td>
          <td class="paramname"><em>aspectFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageView *&#160;</td>
          <td class="paramname"><em>imageView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a view for a Vulkan image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The image for which the view is created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format of the image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewtype</td><td>Vulkan image view type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layerCount</td><td>Number of image layers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aspectFlags</td><td>Flags for how to use the view </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">imageView</td><td>The created image view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="abaaec135aa5e17e36607d4fa3e00d5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaaec135aa5e17e36607d4fa3e00d5a2">&#9670;&nbsp;</a></span>vhBufCreateIndexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhBufCreateIndexBuffer </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocator&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer *&#160;</td>
          <td class="paramname"><em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocation *&#160;</td>
          <td class="paramname"><em>indexBufferAllocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Vulkan index buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>VMA allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command bbuffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indexBuffer</td><td>The new index buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indexBufferAllocation</td><td>VMA allocation information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="acf37e6299054ea7f5138aaa4e426ce72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf37e6299054ea7f5138aaa4e426ce72">&#9670;&nbsp;</a></span>vhBufCreateTexturecubeImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhBufCreateTexturecubeImage </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocator&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gli::texture_cube &amp;&#160;</td>
          <td class="paramname"><em>texCube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage *&#160;</td>
          <td class="paramname"><em>textureImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocation *&#160;</td>
          <td class="paramname"><em>textureImageAllocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat *&#160;</td>
          <td class="paramname"><em>pFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an image that is also a cubemap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>VMA allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command bbuffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">texCube</td><td>The GLI cubemap information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">textureImage</td><td>The new image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">textureImageAllocation</td><td>VMA allocation information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pFormat</td><td>The image format (fixed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a9ffbd8afe369bd26aada3c4935bbfded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ffbd8afe369bd26aada3c4935bbfded">&#9670;&nbsp;</a></span>vhBufCreateTextureImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhBufCreateTextureImage </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocator&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>basedir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>texNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageCreateFlags&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage *&#160;</td>
          <td class="paramname"><em>textureImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocation *&#160;</td>
          <td class="paramname"><em>textureImageAllocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkExtent2D *&#160;</td>
          <td class="paramname"><em>extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a texture image from multiple files. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>The VMA allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command buffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basedir</td><td>Directoy the files are in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">texNames</td><td>List of file names holding the textures (should have same resolution) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Image create flags </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">textureImage</td><td>The new image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">textureImageAllocation</td><td>The VMA allocation info </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extent</td><td>The extent of the loaded image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="ab6871f715a2f97378170122f36283079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6871f715a2f97378170122f36283079">&#9670;&nbsp;</a></span>vhBufCreateTextureSampler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhBufCreateTextureSampler </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSampler *&#160;</td>
          <td class="paramname"><em>textureSampler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an image sampler for samplign textures in shaders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">textureSampler</td><td>The new sampler </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="ab714be58a365d2b553dea57cb4622b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab714be58a365d2b553dea57cb4622b2d">&#9670;&nbsp;</a></span>vhBufCreateUniformBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhBufCreateUniformBuffers </td>
          <td>(</td>
          <td class="paramtype">VmaAllocator&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numberBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkBuffer &gt; &amp;&#160;</td>
          <td class="paramname"><em>uniformBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VmaAllocation &gt; &amp;&#160;</td>
          <td class="paramname"><em>uniformBuffersAllocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a UBO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>VMA allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numberBuffers</td><td>The number of UBOs to be created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of each new buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uniformBuffers</td><td>List containing the new buffers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uniformBuffersAllocation</td><td>VMA allocation information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a6a49e59322f37fb65f61a23c1a6363cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a49e59322f37fb65f61a23c1a6363cb">&#9670;&nbsp;</a></span>vhBufCreateVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhBufCreateVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocator&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structvh_1_1vh_vertex.html">vh::vhVertex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer *&#160;</td>
          <td class="paramname"><em>vertexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocation *&#160;</td>
          <td class="paramname"><em>vertexBufferAllocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Vulkan vertex buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>VMA allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command bbuffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>List of vertices and their data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vertexBuffer</td><td>The new vertex buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vertexBufferAllocation</td><td>VMA allocation information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a06fb4550531664b62cf3a54d377515a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fb4550531664b62cf3a54d377515a7">&#9670;&nbsp;</a></span>vhBufTransitionImageLayout() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhBufTransitionImageLayout </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageAspectFlagBits&#160;</td>
          <td class="paramname"><em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>miplevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>oldLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>newLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transition the image layout, causes a pipeline barrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command buffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The destination image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>The Image format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aspect</td><td>Color or depth </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">miplevels</td><td>Number of image miplevels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layerCount</td><td>Number of image layers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oldLayout</td><td>Old layout of the image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newLayout</td><td>The layout should be transitioned to this new layout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a3bb418fe457b4b3cde96e4499ba2e9e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb418fe457b4b3cde96e4499ba2e9e6">&#9670;&nbsp;</a></span>vhBufTransitionImageLayout() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhBufTransitionImageLayout </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageAspectFlagBits&#160;</td>
          <td class="paramname"><em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>miplevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>oldLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>newLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transition the image layout, causes a pipeline barrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Command buffer to record this operation into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The destination image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>The Image format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aspect</td><td>Color or depth </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">miplevels</td><td>Number of image miplevels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layerCount</td><td>Number of image layers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oldLayout</td><td>Old layout of the image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newLayout</td><td>The layout should be transitioned to this new layout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a2562093b3408ae1d0849c59fff75440a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2562093b3408ae1d0849c59fff75440a">&#9670;&nbsp;</a></span>vhCmdBeginCommandBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhCmdBeginCommandBuffer </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkRenderPass&#160;</td>
          <td class="paramname"><em>renderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>subpass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFramebuffer&#160;</td>
          <td class="paramname"><em>frameBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandBufferUsageFlagBits&#160;</td>
          <td class="paramname"><em>usageFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a command buffer for recording commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">renderPass</td><td>The render pass that is inherited from the parent command buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subpass</td><td>Index of subpass </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frameBuffer</td><td>The framebuffer that is rendered into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>The command buffer to start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usageFlags</td><td>Flags telling how the buffer will be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a9791b75aecc6358fa0be4612d8a83b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9791b75aecc6358fa0be4612d8a83b95">&#9670;&nbsp;</a></span>vhCmdBeginCommandBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhCmdBeginCommandBuffer </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandBufferUsageFlagBits&#160;</td>
          <td class="paramname"><em>usageFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a command buffer for recording commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>The command buffer to start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usageFlags</td><td>Flags telling how the buffer will be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a72b5d170d3b735ede6a6f57806402ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b5d170d3b735ede6a6f57806402ad1">&#9670;&nbsp;</a></span>vhCmdBeginSingleTimeCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkCommandBuffer vh::vhCmdBeginSingleTimeCommands </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin submitting a single time command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command bbuffers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new VkCommandBuffer to record commands into </dd></dl>

</div>
</div>
<a id="afce4235cfc97c6ecc8ba9340ca99a3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce4235cfc97c6ecc8ba9340ca99a3f9">&#9670;&nbsp;</a></span>vhCmdCreateCommandBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhCmdCreateCommandBuffers </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandBufferLevel&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandBuffer *&#160;</td>
          <td class="paramname"><em>pBuffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a number of command buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command bbuffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Level can be primary or secondary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of buffers to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffers</td><td>Pointer to an array where the buffer handles should be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="ac6c523c56a5fe3a0bb7e3dd58a135d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c523c56a5fe3a0bb7e3dd58a135d16">&#9670;&nbsp;</a></span>vhCmdCreateCommandPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhCmdCreateCommandPool </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSurfaceKHR&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool *&#160;</td>
          <td class="paramname"><em>commandPool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new command pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physicalDevice</td><td>Physical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surface</td><td>Window surface - Needed for finding the right queue families </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">commandPool</td><td>New command pool for allocating command bbuffers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a400527c7164faed90b5edac58203d4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400527c7164faed90b5edac58203d4ba">&#9670;&nbsp;</a></span>vhCmdEndSingleTimeCommands() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhCmdEndSingleTimeCommands </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>commandBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End recording into a single time command buffer and submit it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Queue to submit the buffer to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Give back the command buffer to the pool </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>The ready to be used command buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a3d980637f5b78d90e25253cba749e285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d980637f5b78d90e25253cba749e285">&#9670;&nbsp;</a></span>vhCmdEndSingleTimeCommands() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhCmdEndSingleTimeCommands </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSemaphore&#160;</td>
          <td class="paramname"><em>waitSemaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSemaphore&#160;</td>
          <td class="paramname"><em>signalSemaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFence&#160;</td>
          <td class="paramname"><em>waitFence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End recording into a single time command buffer and submit it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Queue to submit the buffer to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Give back the command buffer to the pool </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>The ready to be used command buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waitSemaphore</td><td>A semaphore to wait for before submitting </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signalSemaphore</td><td>Signal this semaphore after buffer is done </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waitFence</td><td>Signal to this fence after buffer is done </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a9ea5120b4ad57ec1f87cf053475bde19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea5120b4ad57ec1f87cf053475bde19">&#9670;&nbsp;</a></span>vhCmdSubmitCommandBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhCmdSubmitCommandBuffer </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSemaphore&#160;</td>
          <td class="paramname"><em>waitSemaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSemaphore&#160;</td>
          <td class="paramname"><em>signalSemaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFence&#160;</td>
          <td class="paramname"><em>waitFence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a command buffer to a queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>The queue the buffer is sent to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>The command buffer that is sent to the queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waitSemaphore</td><td>A semaphore to wait for before submitting </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signalSemaphore</td><td>Signal this semaphore after buffer is done </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waitFence</td><td>Signal to this fence after buffer is done </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a451d818d1649c7341bbb892953716573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451d818d1649c7341bbb892953716573">&#9670;&nbsp;</a></span>vhDevCreateInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhDevCreateInstance </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const char * &gt; &amp;&#160;</td>
          <td class="paramname"><em>extensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const char * &gt; &amp;&#160;</td>
          <td class="paramname"><em>validationLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkInstance *&#160;</td>
          <td class="paramname"><em>instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Vulkan instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">extensions</td><td>Requested layers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">validationLayers</td><td>Requested validation layers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">instance</td><td>The new instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="abef2251fdd3a8f216b82c9a16893578d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef2251fdd3a8f216b82c9a16893578d">&#9670;&nbsp;</a></span>vhDevCreateLogicalDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhDevCreateLogicalDevice </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSurfaceKHR&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const char * &gt;&#160;</td>
          <td class="paramname"><em>requiredDeviceExtensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const char * &gt;&#160;</td>
          <td class="paramname"><em>requiredValidationLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDevice *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue *&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue *&#160;</td>
          <td class="paramname"><em>presentQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a logical device and according queues. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physicalDevice</td><td>The physical device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surface</td><td>Window surface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">requiredDeviceExtensions</td><td>List of required device extensions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">requiredValidationLayers</td><td>List of required validation layers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">device</td><td>The new logical device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">graphicsQueue</td><td>A graphics queue into the device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">presentQueue</td><td>A present queue into the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a8c544f8c40f982eec87405acf83ce225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c544f8c40f982eec87405acf83ce225">&#9670;&nbsp;</a></span>vhDevFindDepthFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkFormat vh::vhDevFindDepthFormat </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>physicalDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a suitable format for the depth/stencil buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physicalDevice</td><td>The physical device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a suitable format that is supported by the physical device </dd></dl>

</div>
</div>
<a id="a8c3bbcd70fcf52ed6b19e0d72b75b2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3bbcd70fcf52ed6b19e0d72b75b2b4">&#9670;&nbsp;</a></span>vhDevFindQueueFamilies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvh_1_1_queue_family_indices.html">QueueFamilyIndices</a> vh::vhDevFindQueueFamilies </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSurfaceKHR&#160;</td>
          <td class="paramname"><em>surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find suitable queue families of a given physical device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>A physical device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surface</td><td>The surface of a window </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a structure containing queue family indices of suitable families </dd></dl>

</div>
</div>
<a id="a81c685442b0d3f4a3dc89177f8d6f11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c685442b0d3f4a3dc89177f8d6f11b">&#9670;&nbsp;</a></span>vhDevFindSupportedFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkFormat vh::vhDevFindSupportedFormat </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; VkFormat &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageTiling&#160;</td>
          <td class="paramname"><em>tiling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormatFeatureFlags&#160;</td>
          <td class="paramname"><em>features</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query a suitable image format that the device supports. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physicalDevice</td><td>The physical device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">candidates</td><td>A list with candidate formats </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tiling</td><td>Linear or optimal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">features</td><td>Usage of the format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a suitable format that is supported by the physical device </dd></dl>

</div>
</div>
<a id="aec90a175a6a85803cef70c3c41ce365f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec90a175a6a85803cef70c3c41ce365f">&#9670;&nbsp;</a></span>vhDevPickPhysicalDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhDevPickPhysicalDevice </td>
          <td>(</td>
          <td class="paramtype">VkInstance&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSurfaceKHR&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const char * &gt;&#160;</td>
          <td class="paramname"><em>requiredDeviceExtensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPhysicalDevice *&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPhysicalDeviceFeatures *&#160;</td>
          <td class="paramname"><em>pFeatures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPhysicalDeviceLimits *&#160;</td>
          <td class="paramname"><em>limits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether a physical offers all required extensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>The Vulkan instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surface</td><td>A window surface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">requiredDeviceExtensions</td><td>A list of required device extensions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">physicalDevice</td><td>A physical device that supports all required extensions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pFeatures</td><td>The features supported by this device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">limits</td><td>The physical limits of the physical device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="af70e43347ac845d3a98dd5a3ac36bf11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70e43347ac845d3a98dd5a3ac36bf11">&#9670;&nbsp;</a></span>vhDevQuerySwapChainSupport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvh_1_1_swap_chain_support_details.html">SwapChainSupportDetails</a> vh::vhDevQuerySwapChainSupport </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSurfaceKHR&#160;</td>
          <td class="paramname"><em>surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query which swap chains a physical device supports. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>A physical device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surface</td><td>A window surface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a structure holding details about capabilities, formats and present modes offered by the device </dd></dl>

</div>
</div>
<a id="a3e1916a9160bee6b83f7f9effd3cdd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1916a9160bee6b83f7f9effd3cdd34">&#9670;&nbsp;</a></span>vhFileRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; char &gt; vh::vhFileRead </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the contents of a file and return a binary blob with it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Filename </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a binary blob containing the file. </dd></dl>

</div>
</div>
<a id="a0423ae2bd016c8eb50c1750059e811c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0423ae2bd016c8eb50c1750059e811c3">&#9670;&nbsp;</a></span>vhMemBlockAdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhMemBlockAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvh_1_1vh_memory_block.html">vhMemoryBlock</a> *&#160;</td>
          <td class="paramname"><em>pBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvh_1_1vh_memory_handle.html">vhMemoryHandle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an entry to a memory block (not a block list) </p>
<p>This function should only be called for single memory blocks that are not part of a block list. If the block gets full, it is reallocated with twice the old capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlock</td><td>The memory block to be appended </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">owner</td><td>Pointer to the entry owner </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A handle to the entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a416256074e592e0204883ac3e3d2361b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416256074e592e0204883ac3e3d2361b">&#9670;&nbsp;</a></span>vhMemBlockDeallocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhMemBlockDeallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvh_1_1vh_memory_block.html">vhMemoryBlock</a> *&#160;</td>
          <td class="paramname"><em>pBlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate the memory from a block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlock</td><td>The memory block that is to be deleted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="ab24b12561d007b25ffc99ab0a990d813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24b12561d007b25ffc99ab0a990d813">&#9670;&nbsp;</a></span>vhMemBlockInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhMemBlockInit </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocator&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDescriptorPool&#160;</td>
          <td class="paramname"><em>descriptorPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDescriptorSetLayout&#160;</td>
          <td class="paramname"><em>descriptorLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxNumEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sizeEntry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvh_1_1vh_memory_block.html">vhMemoryBlock</a> *&#160;</td>
          <td class="paramname"><em>pBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a single memory block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>The logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>The VMA allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptorPool</td><td>Descriptor pool for creating descriptor sets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptorLayout</td><td>Descriptor layout for creating descriptor sets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxNumEntries</td><td>Maximum number of entries in a memory block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizeEntry</td><td>Size of an entry in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numBuffers</td><td>Number of buffers (one for each framebuffer) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlock</td><td>A pointer to the memory block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="aa2ca7c6b6a5a41f490eb3399590d4b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ca7c6b6a5a41f490eb3399590d4b7a">&#9670;&nbsp;</a></span>vhMemBlockListAdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhMemBlockListAdd </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structvh_1_1vh_memory_block.html">vhMemoryBlock</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>blocklist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvh_1_1vh_memory_handle.html">vhMemoryHandle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an entry to a memory block list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blocklist</td><td>The memory block list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">owner</td><td>Pointer to the entry owner </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A handle to the entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a106c314c7a88deb8050948301ea30012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106c314c7a88deb8050948301ea30012">&#9670;&nbsp;</a></span>vhMemBlockListClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhMemBlockListClear </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structvh_1_1vh_memory_block.html">vhMemoryBlock</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>blocklist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all entries and all blocks from a block list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blocklist</td><td>The memory block list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a201d7925aad9bb6685ceba7d73285d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201d7925aad9bb6685ceba7d73285d40">&#9670;&nbsp;</a></span>vhMemBlockListInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhMemBlockListInit </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocator&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDescriptorPool&#160;</td>
          <td class="paramname"><em>descriptorPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDescriptorSetLayout&#160;</td>
          <td class="paramname"><em>descriptorLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxNumEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sizeEntry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structvh_1_1vh_memory_block.html">vhMemoryBlock</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>blocklist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a list of memory blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>The logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>The VMA allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptorPool</td><td>Descriptor pool for creating descriptor sets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptorLayout</td><td>Descriptor layout for creating descriptor sets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxNumEntries</td><td>Maximum number of entries in a memory block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizeEntry</td><td>Size of an entry in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numBuffers</td><td>Number of buffers (one for each framebuffer) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocklist</td><td>A reference to the memory block list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a613fe5f8bf3159e698b7188fdc5e39a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613fe5f8bf3159e698b7188fdc5e39a1">&#9670;&nbsp;</a></span>vhMemBlockMoveEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhMemBlockMoveEntry </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structvh_1_1vh_memory_block.html">vhMemoryBlock</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>dstblocklist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvh_1_1vh_memory_handle.html">vhMemoryHandle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move a handle from one list to another list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dstblocklist</td><td>The destination block list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>Pointer to the handle of the entry that should be moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a5eabede71703c653a56339072b352162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eabede71703c653a56339072b352162">&#9670;&nbsp;</a></span>vhMemBlockRemoveEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhMemBlockRemoveEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvh_1_1vh_memory_handle.html">vhMemoryHandle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an entry from a memory block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>Pointer to the handle of the entry that should be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a83b1662591a2f820b12a485a17a8f2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b1662591a2f820b12a485a17a8f2a0">&#9670;&nbsp;</a></span>vhMemBlockUpdateBlockList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhMemBlockUpdateBlockList </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structvh_1_1vh_memory_block.html">vhMemoryBlock</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>blocklist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update all memory blocks by copying them to the GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blocklist</td><td>The memory blocks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the buffer to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a05a86b5a941fb7fe31e3b10e9777461c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a86b5a941fb7fe31e3b10e9777461c">&#9670;&nbsp;</a></span>vhMemBlockUpdateEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhMemBlockUpdateEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvh_1_1vh_memory_handle.html">vhMemoryHandle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update an entry in one of the memory blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>Pointer to the handle of the entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to a block of data that should be written over the entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a7973d81d63d37347572c19477529dd7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7973d81d63d37347572c19477529dd7f">&#9670;&nbsp;</a></span>vhMemCreateVMAAllocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhMemCreateVMAAllocator </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocator &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the VMA allocator library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physicalDevice</td><td>Physical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allocator</td><td>The created VMA allocator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a5f76d8d8eeb5c06b7f55273a79d9830d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f76d8d8eeb5c06b7f55273a79d9830d">&#9670;&nbsp;</a></span>vhMemFindMemoryType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vh::vhMemFindMemoryType </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>typeFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkMemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the right memory type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physicalDevice</td><td>Physical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">typeFilter</td><td>Memory type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">properties</td><td>Desired memory properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of memory heap that fulfills the properties </dd></dl>

</div>
</div>
<a id="a1a7b7ff0f821ebef5c91f82314ddd7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7b7ff0f821ebef5c91f82314ddd7da">&#9670;&nbsp;</a></span>vhPipeCreateGraphicsPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhPipeCreateGraphicsPipeline </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>shaderFileNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkExtent2D&#160;</td>
          <td class="paramname"><em>swapChainExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipelineLayout&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkRenderPass&#160;</td>
          <td class="paramname"><em>renderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkDynamicState &gt;&#160;</td>
          <td class="paramname"><em>dynamicStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipeline *&#160;</td>
          <td class="paramname"><em>graphicsPipeline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pipeline state object (PSO) for a light pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shaderFileNames</td><td>List of filenames for the shaders: vertex, fragment, geometry, tess control, tess eval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swapChainExtent</td><td>Swapchain extent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pipelineLayout</td><td>Pipeline layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">renderPass</td><td>Renderpass to be used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dynamicStates</td><td>List of dynamic states that can be changed during usage of the pipeline </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">graphicsPipeline</td><td>The new PSO </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="add7ac38cec91ccc1cb7f7fc295735651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7ac38cec91ccc1cb7f7fc295735651">&#9670;&nbsp;</a></span>vhPipeCreateGraphicsPipelineLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhPipeCreateGraphicsPipelineLayout </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkDescriptorSetLayout &gt;&#160;</td>
          <td class="paramname"><em>descriptorSetLayouts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkPushConstantRange &gt;&#160;</td>
          <td class="paramname"><em>pushConstantRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipelineLayout *&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pipeline layout for drawing a light pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptorSetLayouts</td><td>Descriptor set layouts </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pushConstantRanges</td><td>A list with push constant ranges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pipelineLayout</td><td>Resulting pipline layout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a0abe327f01dff0d2f8af18263ee4b768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abe327f01dff0d2f8af18263ee4b768">&#9670;&nbsp;</a></span>vhPipeCreateGraphicsShadowPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhPipeCreateGraphicsShadowPipeline </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>verShaderFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkExtent2D&#160;</td>
          <td class="paramname"><em>shadowMapExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipelineLayout&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkRenderPass&#160;</td>
          <td class="paramname"><em>renderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipeline *&#160;</td>
          <td class="paramname"><em>graphicsPipeline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pipeline state object (PSO) for a shadow pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verShaderFilename</td><td>Name of the vetex shader file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shadowMapExtent</td><td>Swapchain extent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pipelineLayout</td><td>Pipeline layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">renderPass</td><td>Renderpass to be used </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">graphicsPipeline</td><td>The new PSO </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a7579b97116c0e15eecd4bd0ede9dea08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7579b97116c0e15eecd4bd0ede9dea08">&#9670;&nbsp;</a></span>vhPipeCreateShaderModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkShaderModule vh::vhPipeCreateShaderModule </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a shader module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>Blob of bytes that hold the SPIR-V shader code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shader module </dd></dl>

</div>
</div>
<a id="afbe67797af87d26e35dc90d6432a3168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe67797af87d26e35dc90d6432a3168">&#9670;&nbsp;</a></span>vhRenderBeginRenderPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhRenderBeginRenderPass </td>
          <td>(</td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkRenderPass&#160;</td>
          <td class="paramname"><em>renderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFramebuffer&#160;</td>
          <td class="paramname"><em>frameBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkExtent2D&#160;</td>
          <td class="paramname"><em>extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSubpassContents&#160;</td>
          <td class="paramname"><em>subPassContents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start rendering in a command buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>The command buffer to record into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">renderPass</td><td>The render pass that should be begun </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frameBuffer</td><td>The framebuffer for the render pass </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extent</td><td>Extent of the framebuffer images </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subPassContents</td><td>Specifies whether cmd buffers are inline or use secondary bufers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="ae47e43e06e94906f31442d1546a6d3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47e43e06e94906f31442d1546a6d3a7">&#9670;&nbsp;</a></span>vhRenderBeginRenderPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhRenderBeginRenderPass </td>
          <td>(</td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkRenderPass&#160;</td>
          <td class="paramname"><em>renderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFramebuffer&#160;</td>
          <td class="paramname"><em>frameBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkClearValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>clearValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkExtent2D&#160;</td>
          <td class="paramname"><em>extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSubpassContents&#160;</td>
          <td class="paramname"><em>subPassContents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start rendering in a command buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>The command buffer to record into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">renderPass</td><td>The render pass that should be begun </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frameBuffer</td><td>The framebuffer for the render pass </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clearValues</td><td>A list of clear values to clear render targets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extent</td><td>Extent of the framebuffer images </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subPassContents</td><td>Specifies whether cmd buffers are inline or use secondary bufers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a9392ff3d54398fa4297a442ba2a0efb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9392ff3d54398fa4297a442ba2a0efb9">&#9670;&nbsp;</a></span>vhRenderCreateDescriptorPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhRenderCreateDescriptorPool </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkDescriptorType &gt;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>numberDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDescriptorPool *&#160;</td>
          <td class="paramname"><em>descriptorPool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a descriptor pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>The logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">types</td><td>Contains the resource types in the pool </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numberDesc</td><td>Denotes how many of them are in the pool </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">descriptorPool</td><td>The new descriptor pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="ace68f67085dba10e4361d22dc099efe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace68f67085dba10e4361d22dc099efe6">&#9670;&nbsp;</a></span>vhRenderCreateDescriptorSetLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhRenderCreateDescriptorSetLayout </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkDescriptorType &gt;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkShaderStageFlags &gt;&#160;</td>
          <td class="paramname"><em>stageFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDescriptorSetLayout *&#160;</td>
          <td class="paramname"><em>descriptorSetLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a descriptor layout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>The logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counts</td><td>The number of images in an array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">types</td><td>Contains the resource types for the increasing bindings </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stageFlags</td><td>Denotes in which stages they should be used </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">descriptorSetLayout</td><td>The new descriptor set layout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a2e15c0ed7b15c786bc1bc9f6a574c350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e15c0ed7b15c786bc1bc9f6a574c350">&#9670;&nbsp;</a></span>vhRenderCreateDescriptorSets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhRenderCreateDescriptorSets </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numberDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDescriptorSetLayout&#160;</td>
          <td class="paramname"><em>descriptorSetLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDescriptorPool&#160;</td>
          <td class="paramname"><em>descriptorPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkDescriptorSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>descriptorSets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a number of descriptor sets, one for each frame in the swapchain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>The logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numberDesc</td><td>Number of sets to be created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptorSetLayout</td><td>The layout for the set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptorPool</td><td>The pool from which the set is drawn </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">descriptorSets</td><td>Vector with desriptor sets, the new sets will be appended to this vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="aebf05b4e0ad73129da84053e0b354c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf05b4e0ad73129da84053e0b354c9e">&#9670;&nbsp;</a></span>vhRenderCreateRenderPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhRenderCreateRenderPass </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>swapChainImageFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>depthFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkAttachmentLoadOp&#160;</td>
          <td class="paramname"><em>loadOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkRenderPass *&#160;</td>
          <td class="paramname"><em>renderPass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a render pass for a light pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>The logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swapChainImageFormat</td><td>The swap chain image format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depthFormat</td><td>The depth map image format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">loadOp</td><td>Operation what to do with the framebuffer when starting the render pass: clear, keep, or dont care </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">renderPass</td><td>The new render pass </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="abfb40be113bdc3486e32a2553561a279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb40be113bdc3486e32a2553561a279">&#9670;&nbsp;</a></span>vhRenderCreateRenderPassShadow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhRenderCreateRenderPassShadow </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>depthFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkRenderPass *&#160;</td>
          <td class="paramname"><em>renderPass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a render pass for a shadow pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>The logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depthFormat</td><td>The depth map image format </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">renderPass</td><td>The new render pass </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a4390e33b2435fdbf76124fdafe6fba2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4390e33b2435fdbf76124fdafe6fba2a">&#9670;&nbsp;</a></span>vhRenderPresentResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhRenderPresentResult </td>
          <td>(</td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>presentQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSwapchainKHR&#160;</td>
          <td class="paramname"><em>swapChain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>imageIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSemaphore&#160;</td>
          <td class="paramname"><em>signalSemaphore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Present the result of a render operation to a window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">presentQueue</td><td>The present queue that the image is sent to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swapChain</td><td>The Vulkan swap chain </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imageIndex</td><td>Index of the swap chain image currently used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signalSemaphore</td><td>Semaphore that should be signaled once the operation is done </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a686da75542975aa5930179c54bc17306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686da75542975aa5930179c54bc17306">&#9670;&nbsp;</a></span>vhRenderUpdateDescriptorSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhRenderUpdateDescriptorSet </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDescriptorSet&#160;</td>
          <td class="paramname"><em>descriptorSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkBuffer &gt;&#160;</td>
          <td class="paramname"><em>uniformBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>bufferRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; VkImageView &gt;&gt;&#160;</td>
          <td class="paramname"><em>textureImageViews</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; VkSampler &gt;&gt;&#160;</td>
          <td class="paramname"><em>textureSamplers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a descriptor set. </p>
<p>Since it can contain variable number of resources, the lists contain either uniformBuffers or imageViews/sampler. The size of the lists MUST be the same!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptorSet</td><td>The descriptor set to be updated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uniformBuffers</td><td>List of UBOs (can contain null handles) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferRanges</td><td>List of buffer sizes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">textureImageViews</td><td>List of texture image views to be updated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">textureSamplers</td><td>List of texture image samplers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="afab6a4f31575479f0449c03cff83a3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab6a4f31575479f0449c03cff83a3c0">&#9670;&nbsp;</a></span>vhRenderUpdateDescriptorSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhRenderUpdateDescriptorSet </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDescriptorSet&#160;</td>
          <td class="paramname"><em>descriptorSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkDescriptorType &gt;&#160;</td>
          <td class="paramname"><em>descriptorTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkBuffer &gt;&#160;</td>
          <td class="paramname"><em>uniformBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>bufferRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; VkImageView &gt;&gt;&#160;</td>
          <td class="paramname"><em>textureImageViews</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; VkSampler &gt;&gt;&#160;</td>
          <td class="paramname"><em>textureSamplers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a descriptor set. </p>
<p>Since it can contain variable number of resources, the lists contain either uniformBuffers or imageViews/sampler. The size of the lists MUST be the same!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptorSet</td><td>The descriptor set to be updated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptorTypes</td><td>A list with the descriptor types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uniformBuffers</td><td>List of UBOs (can contain null handles) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferRanges</td><td>List of buffer sizes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">textureImageViews</td><td>List of texture image views to be updated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">textureSamplers</td><td>List of texture image samplers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a869d9fac1760fdf3ca8b7abcc2c143e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869d9fac1760fdf3ca8b7abcc2c143e9">&#9670;&nbsp;</a></span>vhRenderUpdateDescriptorSetMaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhRenderUpdateDescriptorSetMaps </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDescriptorSet&#160;</td>
          <td class="paramname"><em>descriptorSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>descriptorCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; VkDescriptorImageInfo &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>maps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a descriptor set being composed of arrays of textures. </p>
<p>A shader may use arrays of textures, e.g. one for albedo, one for normal maps., one for metalness etc. This funtion binds a subset of existing image infos such that the shader can access them as arrays of textures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptorSet</td><td>The descriptor set to be updated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">binding</td><td>Start binding number, array bindings begin with this number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Start idx for the array of image infos </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptorCount</td><td>Number of images in the array = array length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maps</td><td>List of image info lists </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS or a Vulkan error code </dd></dl>

</div>
</div>
<a id="a6d0e56b8ed7309e0ebf5ba969323e4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0e56b8ed7309e0ebf5ba969323e4db">&#9670;&nbsp;</a></span>vhSwapCreateSwapChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhSwapCreateSwapChain </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSurfaceKHR&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkExtent2D&#160;</td>
          <td class="paramname"><em>frameBufferExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSwapchainKHR *&#160;</td>
          <td class="paramname"><em>swapChain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkImage &gt; &amp;&#160;</td>
          <td class="paramname"><em>swapChainImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkImageView &gt; &amp;&#160;</td>
          <td class="paramname"><em>swapChainImageViews</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat *&#160;</td>
          <td class="paramname"><em>swapChainImageFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkExtent2D *&#160;</td>
          <td class="paramname"><em>swapChainExtent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose the swapchain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physicalDevice</td><td>The physical device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surface</td><td>The window surface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frameBufferExtent</td><td>Extent of the framebuffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">swapChain</td><td>The new swapchain </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">swapChainImages</td><td>A list containing the swapchain images </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">swapChainImageViews</td><td>A list containing swapchain image views </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">swapChainImageFormat</td><td>A list containing swapchain image formats </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">swapChainExtent</td><td>Swapchain extent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19eaffd746fc8a31941d4559ca0894c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19eaffd746fc8a31941d4559ca0894c0">&#9670;&nbsp;</a></span>vhTimeDuration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float vh::vhTimeDuration </td>
          <td>(</td>
          <td class="paramtype">std::chrono::high_resolution_clock::time_point&#160;</td>
          <td class="paramname"><em>t_prev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the high resolution clock to calculate a time duration since the last time measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t_prev</td><td>The last time measruement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the measured time duration </dd></dl>

</div>
</div>
<a id="a4fad56183a7e4ab61241a8873a247ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fad56183a7e4ab61241a8873a247ea1">&#9670;&nbsp;</a></span>vhTimeNow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::high_resolution_clock::time_point vh::vhTimeNow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a time measurment from the high resolution clock. </p>
<dl class="section return"><dt>Returns</dt><dd>the measured value of the clock </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 27 2019 17:18:39 for Vienna Vulkan Engine by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
