<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vienna Vulkan Engine: vh Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vienna Vulkan Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vh Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvh_1_1_queue_family_indices.html">QueueFamilyIndices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">need only for start up  <a href="structvh_1_1_queue_family_indices.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvh_1_1_swap_chain_support_details.html">SwapChainSupportDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">need only for start up  <a href="structvh_1_1_swap_chain_support_details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvh_1_1vh_vertex.html">vhVertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">per vertex data that is stored in the vertex buffers  <a href="structvh_1_1vh_vertex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a86a2c772e5f54ed38ca9a14ee67ce2ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a86a2c772e5f54ed38ca9a14ee67ce2ed">vhBufCreateBuffer</a> (VmaAllocator allocator, VkDeviceSize size, VkBufferUsageFlags usage, VmaMemoryUsage vmaUsage, VkBuffer *buffer, VmaAllocation *allocation)</td></tr>
<tr class="memdesc:a86a2c772e5f54ed38ca9a14ee67ce2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Vulkan buffer.  <a href="#a86a2c772e5f54ed38ca9a14ee67ce2ed">More...</a><br /></td></tr>
<tr class="separator:a86a2c772e5f54ed38ca9a14ee67ce2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dffa38557f5880ca9cedb269d3e45cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a2dffa38557f5880ca9cedb269d3e45cb">vhBufCopyBuffer</a> (VkDevice device, VkQueue graphicsQueue, VkCommandPool commandPool, VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size)</td></tr>
<tr class="memdesc:a2dffa38557f5880ca9cedb269d3e45cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a buffer from a source buffer to a destination buffer.  <a href="#a2dffa38557f5880ca9cedb269d3e45cb">More...</a><br /></td></tr>
<tr class="separator:a2dffa38557f5880ca9cedb269d3e45cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bbfc56732a182fe87f10ce967699ed"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ae5bbfc56732a182fe87f10ce967699ed">vhBufCreateImageView</a> (VkDevice device, VkImage image, VkFormat format, VkImageViewType viewtype, uint32_t layerCount, VkImageAspectFlags aspectFlags, VkImageView *imageView)</td></tr>
<tr class="memdesc:ae5bbfc56732a182fe87f10ce967699ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a view for a Vulkan image.  <a href="#ae5bbfc56732a182fe87f10ce967699ed">More...</a><br /></td></tr>
<tr class="separator:ae5bbfc56732a182fe87f10ce967699ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e43f0f3007c092b6cfea3b4d2eb925"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a28e43f0f3007c092b6cfea3b4d2eb925">vhBufCreateDepthResources</a> (VkDevice device, VmaAllocator allocator, VkQueue graphicsQueue, VkCommandPool commandPool, VkExtent2D extent, VkFormat depthFormat, VkImage *depthImage, VmaAllocation *depthImageAllocation, VkImageView *depthImageView)</td></tr>
<tr class="memdesc:a28e43f0f3007c092b6cfea3b4d2eb925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a depth image and a view to be used as depth map.  <a href="#a28e43f0f3007c092b6cfea3b4d2eb925">More...</a><br /></td></tr>
<tr class="separator:a28e43f0f3007c092b6cfea3b4d2eb925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9240248076972838fd5410d4433b8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a5f9240248076972838fd5410d4433b8b">vhBufCreateImage</a> (VmaAllocator allocator, uint32_t width, uint32_t height, uint32_t miplevels, uint32_t arrayLayers, VkFormat format, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImage *image, VmaAllocation *allocation)</td></tr>
<tr class="memdesc:a5f9240248076972838fd5410d4433b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Vulkan image using VMA.  <a href="#a5f9240248076972838fd5410d4433b8b">More...</a><br /></td></tr>
<tr class="separator:a5f9240248076972838fd5410d4433b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a765fa525c8857895ba358996a2938"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a77a765fa525c8857895ba358996a2938">hasStencilComponent</a> (VkFormat format)</td></tr>
<tr class="separator:a77a765fa525c8857895ba358996a2938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c34f2bae24f3129f4c846227a336833"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a1c34f2bae24f3129f4c846227a336833">vhBufCopyBufferToImage</a> (VkDevice device, VkQueue graphicsQueue, VkCommandPool commandPool, VkBuffer buffer, VkImage image, uint32_t layerCount, uint32_t width, uint32_t height)</td></tr>
<tr class="memdesc:a1c34f2bae24f3129f4c846227a336833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a buffer to an image (for uploading via a staging buffer)  <a href="#a1c34f2bae24f3129f4c846227a336833">More...</a><br /></td></tr>
<tr class="separator:a1c34f2bae24f3129f4c846227a336833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80851c019a6b6a029a08aeff02cf03f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ac80851c019a6b6a029a08aeff02cf03f">vhBufCopyBufferToImage</a> (VkDevice device, VkQueue graphicsQueue, VkCommandPool commandPool, VkBuffer buffer, VkImage image, std::vector&lt; VkBufferImageCopy &gt; &amp;regions, uint32_t width, uint32_t height)</td></tr>
<tr class="memdesc:ac80851c019a6b6a029a08aeff02cf03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for copying a buffer to an image, manages queue submission.  <a href="#ac80851c019a6b6a029a08aeff02cf03f">More...</a><br /></td></tr>
<tr class="separator:ac80851c019a6b6a029a08aeff02cf03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15b3523d6fa3fc5e3ba7c016a60472a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#aa15b3523d6fa3fc5e3ba7c016a60472a">vhBufCopyImageToBuffer</a> (VkDevice device, VkQueue graphicsQueue, VkCommandPool commandPool, VkImage image, VkImageAspectFlagBits aspect, VkBuffer buffer, uint32_t layerCount, uint32_t width, uint32_t height)</td></tr>
<tr class="memdesc:aa15b3523d6fa3fc5e3ba7c016a60472a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a VKImage to a VKBuffer.  <a href="#aa15b3523d6fa3fc5e3ba7c016a60472a">More...</a><br /></td></tr>
<tr class="separator:aa15b3523d6fa3fc5e3ba7c016a60472a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694a95f414d8bc28efcbbf667a7e58f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a694a95f414d8bc28efcbbf667a7e58f9">vhBufCopyImageToBuffer</a> (VkDevice device, VkQueue graphicsQueue, VkCommandPool commandPool, VkImage image, VkBuffer buffer, std::vector&lt; VkBufferImageCopy &gt; &amp;regions, uint32_t width, uint32_t height)</td></tr>
<tr class="memdesc:a694a95f414d8bc28efcbbf667a7e58f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a VKImage to a VKBuffer.  <a href="#a694a95f414d8bc28efcbbf667a7e58f9">More...</a><br /></td></tr>
<tr class="separator:a694a95f414d8bc28efcbbf667a7e58f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28d13df6b14efaebef29dde2b1b7674"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ad28d13df6b14efaebef29dde2b1b7674">vhBufTransitionImageLayout</a> (VkDevice device, VkQueue graphicsQueue, VkCommandPool commandPool, VkImage image, VkFormat format, VkImageAspectFlagBits aspect, uint32_t miplevels, uint32_t layerCount, VkImageLayout oldLayout, VkImageLayout newLayout)</td></tr>
<tr class="memdesc:ad28d13df6b14efaebef29dde2b1b7674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition the image layout, causes a pipeline barrier.  <a href="#ad28d13df6b14efaebef29dde2b1b7674">More...</a><br /></td></tr>
<tr class="separator:ad28d13df6b14efaebef29dde2b1b7674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f3a6b1cca391a5c133f8026c0d7d81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a71f3a6b1cca391a5c133f8026c0d7d81">vhBufTransitionImageLayout</a> (VkDevice device, VkQueue graphicsQueue, VkCommandBuffer commandBuffer, VkImage image, VkFormat format, VkImageAspectFlagBits aspect, uint32_t miplevels, uint32_t layerCount, VkImageLayout oldLayout, VkImageLayout newLayout)</td></tr>
<tr class="memdesc:a71f3a6b1cca391a5c133f8026c0d7d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition the image layout, causes a pipeline barrier.  <a href="#a71f3a6b1cca391a5c133f8026c0d7d81">More...</a><br /></td></tr>
<tr class="separator:a71f3a6b1cca391a5c133f8026c0d7d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2615cec03ffb7297f65f9c485bb53d2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a2615cec03ffb7297f65f9c485bb53d2e">vhBufCreateTextureImage</a> (VkDevice device, VmaAllocator allocator, VkQueue graphicsQueue, VkCommandPool commandPool, std::string basedir, std::vector&lt; std::string &gt; texNames, VkImageCreateFlags flags, VkImage *textureImage, VmaAllocation *textureImageAllocation, VkExtent2D *extent)</td></tr>
<tr class="memdesc:a2615cec03ffb7297f65f9c485bb53d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a texture image from multiple files.  <a href="#a2615cec03ffb7297f65f9c485bb53d2e">More...</a><br /></td></tr>
<tr class="separator:a2615cec03ffb7297f65f9c485bb53d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7733e09fb0e2664562663d6a81874976"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a7733e09fb0e2664562663d6a81874976">vhBufCreateTexturecubeImage</a> (VkDevice device, VmaAllocator allocator, VkQueue graphicsQueue, VkCommandPool commandPool, gli::texture_cube &amp;texCube, VkImage *textureImage, VmaAllocation *textureImageAllocation, VkFormat *pFormat)</td></tr>
<tr class="separator:a7733e09fb0e2664562663d6a81874976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d7fe471ccd3e065a3e5e6117857e8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#aa9d7fe471ccd3e065a3e5e6117857e8c">vhBufCreateTextureSampler</a> (VkDevice device, VkSampler *textureSampler)</td></tr>
<tr class="memdesc:aa9d7fe471ccd3e065a3e5e6117857e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an image sampler for samplign textures in shaders.  <a href="#aa9d7fe471ccd3e065a3e5e6117857e8c">More...</a><br /></td></tr>
<tr class="separator:aa9d7fe471ccd3e065a3e5e6117857e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ba7ea8497eed149b5fda470cb71a78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a54ba7ea8497eed149b5fda470cb71a78">vhBufCreateFramebuffers</a> (VkDevice device, std::vector&lt; VkImageView &gt; imageViews, std::vector&lt; VkImageView &gt; depthImageViews, VkRenderPass renderPass, VkExtent2D extent, std::vector&lt; VkFramebuffer &gt; &amp;frameBuffers)</td></tr>
<tr class="memdesc:a54ba7ea8497eed149b5fda470cb71a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create framebuffers (color + depth), one for each swap chain image.  <a href="#a54ba7ea8497eed149b5fda470cb71a78">More...</a><br /></td></tr>
<tr class="separator:a54ba7ea8497eed149b5fda470cb71a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6671c2b172d2263c11068f75ae423207"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a6671c2b172d2263c11068f75ae423207">vhBufCopySwapChainImageToHost</a> (VkDevice device, VmaAllocator allocator, VkQueue graphicsQueue, VkCommandPool commandPool, VkImage image, VkImageAspectFlagBits aspect, gli::byte *bufferData, uint32_t width, uint32_t height, uint32_t imageSize)</td></tr>
<tr class="memdesc:a6671c2b172d2263c11068f75ae423207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a swap chain image to a data buffer, after it has been rendered into.  <a href="#a6671c2b172d2263c11068f75ae423207">More...</a><br /></td></tr>
<tr class="separator:a6671c2b172d2263c11068f75ae423207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0743986ab234bc389a6f3d2bef61a3f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a0743986ab234bc389a6f3d2bef61a3f7">vhBufCopyImageToHost</a> (VkDevice device, VmaAllocator allocator, VkQueue graphicsQueue, VkCommandPool commandPool, VkImage image, VkFormat format, VkImageAspectFlagBits aspect, VkImageLayout layout, gli::byte *bufferData, uint32_t width, uint32_t height, uint32_t imageSize)</td></tr>
<tr class="memdesc:a0743986ab234bc389a6f3d2bef61a3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a swap chain image to a data buffer, after it has been rendered into.  <a href="#a0743986ab234bc389a6f3d2bef61a3f7">More...</a><br /></td></tr>
<tr class="separator:a0743986ab234bc389a6f3d2bef61a3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90901f6f2cb0f3d551806520abce0dc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a90901f6f2cb0f3d551806520abce0dc8">vhBufCreateVertexBuffer</a> (VkDevice device, VmaAllocator allocator, VkQueue graphicsQueue, VkCommandPool commandPool, std::vector&lt; <a class="el" href="structvh_1_1vh_vertex.html">vh::vhVertex</a> &gt; &amp;vertices, VkBuffer *vertexBuffer, VmaAllocation *vertexBufferAllocation)</td></tr>
<tr class="memdesc:a90901f6f2cb0f3d551806520abce0dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Vulkan vertex buffer.  <a href="#a90901f6f2cb0f3d551806520abce0dc8">More...</a><br /></td></tr>
<tr class="separator:a90901f6f2cb0f3d551806520abce0dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb318e83456d2b7f301ad3a5b1c5a07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a4fb318e83456d2b7f301ad3a5b1c5a07">vhBufCreateIndexBuffer</a> (VkDevice device, VmaAllocator allocator, VkQueue graphicsQueue, VkCommandPool commandPool, std::vector&lt; uint32_t &gt; &amp;indices, VkBuffer *indexBuffer, VmaAllocation *indexBufferAllocation)</td></tr>
<tr class="memdesc:a4fb318e83456d2b7f301ad3a5b1c5a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Vulkan index buffer.  <a href="#a4fb318e83456d2b7f301ad3a5b1c5a07">More...</a><br /></td></tr>
<tr class="separator:a4fb318e83456d2b7f301ad3a5b1c5a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f24ff5c0c1d74b3ee1048d461690a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ac5f24ff5c0c1d74b3ee1048d461690a0">vhBufCreateUniformBuffers</a> (VmaAllocator allocator, uint32_t numberBuffers, VkDeviceSize bufferSize, std::vector&lt; VkBuffer &gt; &amp;uniformBuffers, std::vector&lt; VmaAllocation &gt; &amp;uniformBuffersAllocation)</td></tr>
<tr class="memdesc:ac5f24ff5c0c1d74b3ee1048d461690a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a UBO.  <a href="#ac5f24ff5c0c1d74b3ee1048d461690a0">More...</a><br /></td></tr>
<tr class="separator:ac5f24ff5c0c1d74b3ee1048d461690a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a61b7e654b90be1ff704e4cfbd6f77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a75a61b7e654b90be1ff704e4cfbd6f77">vhCmdCreateCommandPool</a> (VkPhysicalDevice physicalDevice, VkDevice device, VkSurfaceKHR surface, VkCommandPool *commandPool)</td></tr>
<tr class="memdesc:a75a61b7e654b90be1ff704e4cfbd6f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new command pool.  <a href="#a75a61b7e654b90be1ff704e4cfbd6f77">More...</a><br /></td></tr>
<tr class="separator:a75a61b7e654b90be1ff704e4cfbd6f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b5d170d3b735ede6a6f57806402ad1"><td class="memItemLeft" align="right" valign="top">VkCommandBuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a72b5d170d3b735ede6a6f57806402ad1">vhCmdBeginSingleTimeCommands</a> (VkDevice device, VkCommandPool commandPool)</td></tr>
<tr class="memdesc:a72b5d170d3b735ede6a6f57806402ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin submitting a single time command.  <a href="#a72b5d170d3b735ede6a6f57806402ad1">More...</a><br /></td></tr>
<tr class="separator:a72b5d170d3b735ede6a6f57806402ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3561c11e98c2d5ba6fc7a2b53a45ac48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a3561c11e98c2d5ba6fc7a2b53a45ac48">vhCmdEndSingleTimeCommands</a> (VkDevice device, VkQueue graphicsQueue, VkCommandPool commandPool, VkCommandBuffer commandBuffer)</td></tr>
<tr class="memdesc:a3561c11e98c2d5ba6fc7a2b53a45ac48"><td class="mdescLeft">&#160;</td><td class="mdescRight">End recording into a single time command buffer and submit it.  <a href="#a3561c11e98c2d5ba6fc7a2b53a45ac48">More...</a><br /></td></tr>
<tr class="separator:a3561c11e98c2d5ba6fc7a2b53a45ac48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3500d2b026ba0e56835f14742b59d160"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a3500d2b026ba0e56835f14742b59d160">vhCmdEndSingleTimeCommands</a> (VkDevice device, VkQueue graphicsQueue, VkCommandPool commandPool, VkCommandBuffer commandBuffer, VkSemaphore waitSemaphore, VkSemaphore signalSemaphore, VkFence waitFence)</td></tr>
<tr class="memdesc:a3500d2b026ba0e56835f14742b59d160"><td class="mdescLeft">&#160;</td><td class="mdescRight">End recording into a single time command buffer and submit it.  <a href="#a3500d2b026ba0e56835f14742b59d160">More...</a><br /></td></tr>
<tr class="separator:a3500d2b026ba0e56835f14742b59d160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37cb47383e3f370dec52aec254a57b3"><td class="memItemLeft" align="right" valign="top"><a id="ad37cb47383e3f370dec52aec254a57b3"></a>
VKAPI_ATTR VkBool32 VKAPI_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ad37cb47383e3f370dec52aec254a57b3">vhDebugCallback</a> (VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objType, uint64_t obj, size_t location, int32_t code, const char *layerPrefix, const char *msg, void *userData)</td></tr>
<tr class="memdesc:ad37cb47383e3f370dec52aec254a57b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug callback. <br /></td></tr>
<tr class="separator:ad37cb47383e3f370dec52aec254a57b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6636471ca9dcc2d2c74c54f5f8ad39"><td class="memItemLeft" align="right" valign="top"><a id="aae6636471ca9dcc2d2c74c54f5f8ad39"></a>
VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#aae6636471ca9dcc2d2c74c54f5f8ad39">vhDebugCreateReportCallbackEXT</a> (VkInstance instance, const VkDebugReportCallbackCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugReportCallbackEXT *pCallback)</td></tr>
<tr class="memdesc:aae6636471ca9dcc2d2c74c54f5f8ad39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get debug callback function handle. <br /></td></tr>
<tr class="separator:aae6636471ca9dcc2d2c74c54f5f8ad39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6ae9a805291e72699e3eb99629f430"><td class="memItemLeft" align="right" valign="top"><a id="afd6ae9a805291e72699e3eb99629f430"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#afd6ae9a805291e72699e3eb99629f430">vhDebugDestroyReportCallbackEXT</a> (VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks *pAllocator)</td></tr>
<tr class="memdesc:afd6ae9a805291e72699e3eb99629f430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove debug callback. <br /></td></tr>
<tr class="separator:afd6ae9a805291e72699e3eb99629f430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdeb0d9fcda941f0cb92fd857002d309"><td class="memItemLeft" align="right" valign="top"><a id="abdeb0d9fcda941f0cb92fd857002d309"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#abdeb0d9fcda941f0cb92fd857002d309">vhSetupDebugCallback</a> (VkInstance instance, VkDebugReportCallbackEXT *callback)</td></tr>
<tr class="memdesc:abdeb0d9fcda941f0cb92fd857002d309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register debug callback. <br /></td></tr>
<tr class="separator:abdeb0d9fcda941f0cb92fd857002d309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42616af40e6817b748d42deeda488618"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a42616af40e6817b748d42deeda488618">checkValidationLayerSupport</a> (std::vector&lt; const char * &gt; &amp;validationLayers)</td></tr>
<tr class="memdesc:a42616af40e6817b748d42deeda488618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check validation layers of the Vulkan instance.  <a href="#a42616af40e6817b748d42deeda488618">More...</a><br /></td></tr>
<tr class="separator:a42616af40e6817b748d42deeda488618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451d818d1649c7341bbb892953716573"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a451d818d1649c7341bbb892953716573">vhDevCreateInstance</a> (std::vector&lt; const char * &gt; &amp;extensions, std::vector&lt; const char * &gt; &amp;validationLayers, VkInstance *instance)</td></tr>
<tr class="memdesc:a451d818d1649c7341bbb892953716573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Vulkan instance.  <a href="#a451d818d1649c7341bbb892953716573">More...</a><br /></td></tr>
<tr class="separator:a451d818d1649c7341bbb892953716573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3bbcd70fcf52ed6b19e0d72b75b2b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvh_1_1_queue_family_indices.html">QueueFamilyIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a8c3bbcd70fcf52ed6b19e0d72b75b2b4">vhDevFindQueueFamilies</a> (VkPhysicalDevice device, VkSurfaceKHR surface)</td></tr>
<tr class="memdesc:a8c3bbcd70fcf52ed6b19e0d72b75b2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find suitable queue families of a given physical device.  <a href="#a8c3bbcd70fcf52ed6b19e0d72b75b2b4">More...</a><br /></td></tr>
<tr class="separator:a8c3bbcd70fcf52ed6b19e0d72b75b2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8c854df58e16a79055422d1b1f8516"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a5b8c854df58e16a79055422d1b1f8516">checkDeviceExtensionSupport</a> (VkPhysicalDevice device, std::vector&lt; const char * &gt; requiredDeviceExtensions)</td></tr>
<tr class="memdesc:a5b8c854df58e16a79055422d1b1f8516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a given physical device offers a list of required extensions.  <a href="#a5b8c854df58e16a79055422d1b1f8516">More...</a><br /></td></tr>
<tr class="separator:a5b8c854df58e16a79055422d1b1f8516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70e43347ac845d3a98dd5a3ac36bf11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvh_1_1_swap_chain_support_details.html">SwapChainSupportDetails</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#af70e43347ac845d3a98dd5a3ac36bf11">vhDevQuerySwapChainSupport</a> (VkPhysicalDevice device, VkSurfaceKHR surface)</td></tr>
<tr class="memdesc:af70e43347ac845d3a98dd5a3ac36bf11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query which swap chains a physical device supports.  <a href="#af70e43347ac845d3a98dd5a3ac36bf11">More...</a><br /></td></tr>
<tr class="separator:af70e43347ac845d3a98dd5a3ac36bf11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c20b5524c517208b8984d3734f2aea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a57c20b5524c517208b8984d3734f2aea">isDeviceSuitable</a> (VkPhysicalDevice device, VkSurfaceKHR surface, std::vector&lt; const char * &gt; requiredDeviceExtensions)</td></tr>
<tr class="memdesc:a57c20b5524c517208b8984d3734f2aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether a physical offers all required extensions.  <a href="#a57c20b5524c517208b8984d3734f2aea">More...</a><br /></td></tr>
<tr class="separator:a57c20b5524c517208b8984d3734f2aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6875d8352834932f9990c7bfb72be6aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a6875d8352834932f9990c7bfb72be6aa">vhDevPickPhysicalDevice</a> (VkInstance instance, VkSurfaceKHR surface, std::vector&lt; const char * &gt; requiredDeviceExtensions, VkPhysicalDevice *physicalDevice)</td></tr>
<tr class="memdesc:a6875d8352834932f9990c7bfb72be6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether a physical offers all required extensions.  <a href="#a6875d8352834932f9990c7bfb72be6aa">More...</a><br /></td></tr>
<tr class="separator:a6875d8352834932f9990c7bfb72be6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c685442b0d3f4a3dc89177f8d6f11b"><td class="memItemLeft" align="right" valign="top">VkFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a81c685442b0d3f4a3dc89177f8d6f11b">vhDevFindSupportedFormat</a> (VkPhysicalDevice physicalDevice, const std::vector&lt; VkFormat &gt; &amp;candidates, VkImageTiling tiling, VkFormatFeatureFlags features)</td></tr>
<tr class="memdesc:a81c685442b0d3f4a3dc89177f8d6f11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a suitable image format that the device supports.  <a href="#a81c685442b0d3f4a3dc89177f8d6f11b">More...</a><br /></td></tr>
<tr class="separator:a81c685442b0d3f4a3dc89177f8d6f11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c544f8c40f982eec87405acf83ce225"><td class="memItemLeft" align="right" valign="top">VkFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a8c544f8c40f982eec87405acf83ce225">vhDevFindDepthFormat</a> (VkPhysicalDevice physicalDevice)</td></tr>
<tr class="memdesc:a8c544f8c40f982eec87405acf83ce225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a suitable format for the depth/stencil buffer.  <a href="#a8c544f8c40f982eec87405acf83ce225">More...</a><br /></td></tr>
<tr class="separator:a8c544f8c40f982eec87405acf83ce225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cb3a4423dcb39d177d382c4834a396"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a20cb3a4423dcb39d177d382c4834a396">vhDevCreateLogicalDevice</a> (VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, std::vector&lt; const char * &gt; requiredDeviceExtensions, std::vector&lt; const char * &gt; requiredValidationLayers, VkDevice *device, VkQueue *graphicsQueue, VkQueue *presentQueue)</td></tr>
<tr class="memdesc:a20cb3a4423dcb39d177d382c4834a396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a logical device and according queues.  <a href="#a20cb3a4423dcb39d177d382c4834a396">More...</a><br /></td></tr>
<tr class="separator:a20cb3a4423dcb39d177d382c4834a396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1916a9160bee6b83f7f9effd3cdd34"><td class="memItemLeft" align="right" valign="top">std::vector&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a3e1916a9160bee6b83f7f9effd3cdd34">vhFileRead</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a3e1916a9160bee6b83f7f9effd3cdd34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the contents of a file and return a binary blob with it.  <a href="#a3e1916a9160bee6b83f7f9effd3cdd34">More...</a><br /></td></tr>
<tr class="separator:a3e1916a9160bee6b83f7f9effd3cdd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0401ce1a7329f9b52497fff549135f7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a0401ce1a7329f9b52497fff549135f7a">vhSwapCreateSwapChain</a> (VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkDevice device, VkExtent2D frameBufferExtent, VkSwapchainKHR *swapChain, std::vector&lt; VkImage &gt; &amp;swapChainImages, std::vector&lt; VkImageView &gt; &amp;swapChainImageViews, VkFormat *swapChainImageFormat, VkExtent2D *swapChainExtent)</td></tr>
<tr class="memdesc:a0401ce1a7329f9b52497fff549135f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose the swapchain.  <a href="#a0401ce1a7329f9b52497fff549135f7a">More...</a><br /></td></tr>
<tr class="separator:a0401ce1a7329f9b52497fff549135f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e955c65e9f1dd327237cacf2439d81f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a4e955c65e9f1dd327237cacf2439d81f">vhRenderCreateRenderPass</a> (VkDevice device, VkFormat swapChainImageFormat, VkFormat depthFormat, VkAttachmentLoadOp loadOp, VkRenderPass *renderPass)</td></tr>
<tr class="memdesc:a4e955c65e9f1dd327237cacf2439d81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a render pass for a light pass.  <a href="#a4e955c65e9f1dd327237cacf2439d81f">More...</a><br /></td></tr>
<tr class="separator:a4e955c65e9f1dd327237cacf2439d81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1d99ade9bdbbdcb607bcb54dfac0c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#afc1d99ade9bdbbdcb607bcb54dfac0c8">vhRenderCreateRenderPassShadow</a> (VkDevice device, VkFormat depthFormat, VkRenderPass *renderPass)</td></tr>
<tr class="memdesc:afc1d99ade9bdbbdcb607bcb54dfac0c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a render pass for a shadow pass.  <a href="#afc1d99ade9bdbbdcb607bcb54dfac0c8">More...</a><br /></td></tr>
<tr class="separator:afc1d99ade9bdbbdcb607bcb54dfac0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5951d9e013d1bd9fdab39b2ee4516d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#acf5951d9e013d1bd9fdab39b2ee4516d">vhRenderCreateDescriptorSetLayout</a> (VkDevice device, std::vector&lt; uint32_t &gt; counts, std::vector&lt; VkDescriptorType &gt; types, std::vector&lt; VkShaderStageFlags &gt; stageFlags, VkDescriptorSetLayout *descriptorSetLayout)</td></tr>
<tr class="memdesc:acf5951d9e013d1bd9fdab39b2ee4516d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a descriptor layout.  <a href="#acf5951d9e013d1bd9fdab39b2ee4516d">More...</a><br /></td></tr>
<tr class="separator:acf5951d9e013d1bd9fdab39b2ee4516d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f31a918822c6b09d118611bc4e629c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ac8f31a918822c6b09d118611bc4e629c">vhRenderCreateDescriptorPool</a> (VkDevice device, std::vector&lt; VkDescriptorType &gt; types, std::vector&lt; uint32_t &gt; numberDesc, VkDescriptorPool *descriptorPool)</td></tr>
<tr class="memdesc:ac8f31a918822c6b09d118611bc4e629c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a descriptor pool.  <a href="#ac8f31a918822c6b09d118611bc4e629c">More...</a><br /></td></tr>
<tr class="separator:ac8f31a918822c6b09d118611bc4e629c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0c05cca7c6f71779e85f10e25c3878"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a5f0c05cca7c6f71779e85f10e25c3878">vhRenderCreateDescriptorSets</a> (VkDevice device, uint32_t numberDesc, VkDescriptorSetLayout descriptorSetLayout, VkDescriptorPool descriptorPool, std::vector&lt; VkDescriptorSet &gt; &amp;descriptorSets)</td></tr>
<tr class="memdesc:a5f0c05cca7c6f71779e85f10e25c3878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a number of descriptor sets, one for each frame in the swapchain.  <a href="#a5f0c05cca7c6f71779e85f10e25c3878">More...</a><br /></td></tr>
<tr class="separator:a5f0c05cca7c6f71779e85f10e25c3878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c13ad01667cf5bc7c0946bdc61b53b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a6c13ad01667cf5bc7c0946bdc61b53b8">vhRenderUpdateDescriptorSet</a> (VkDevice device, VkDescriptorSet descriptorSet, std::vector&lt; VkBuffer &gt; uniformBuffers, std::vector&lt; uint32_t &gt; bufferRanges, std::vector&lt; std::vector&lt; VkImageView &gt;&gt; textureImageViews, std::vector&lt; std::vector&lt; VkSampler &gt;&gt; textureSamplers)</td></tr>
<tr class="memdesc:a6c13ad01667cf5bc7c0946bdc61b53b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a descriptor set.  <a href="#a6c13ad01667cf5bc7c0946bdc61b53b8">More...</a><br /></td></tr>
<tr class="separator:a6c13ad01667cf5bc7c0946bdc61b53b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33a812099efdb28335db179ab789fd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ad33a812099efdb28335db179ab789fd2">vhRenderBeginRenderPass</a> (VkCommandBuffer commandBuffer, VkRenderPass renderPass, VkFramebuffer frameBuffer, VkExtent2D extent)</td></tr>
<tr class="memdesc:ad33a812099efdb28335db179ab789fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start rendering in a command buffer.  <a href="#ad33a812099efdb28335db179ab789fd2">More...</a><br /></td></tr>
<tr class="separator:ad33a812099efdb28335db179ab789fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ec1b174dce07cb9947b055c354b179"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a55ec1b174dce07cb9947b055c354b179">vhRenderBeginRenderPass</a> (VkCommandBuffer commandBuffer, VkRenderPass renderPass, VkFramebuffer frameBuffer, std::vector&lt; VkClearValue &gt; &amp;clearValues, VkExtent2D extent)</td></tr>
<tr class="memdesc:a55ec1b174dce07cb9947b055c354b179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start rendering in a command buffer.  <a href="#a55ec1b174dce07cb9947b055c354b179">More...</a><br /></td></tr>
<tr class="separator:a55ec1b174dce07cb9947b055c354b179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4390e33b2435fdbf76124fdafe6fba2a"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a4390e33b2435fdbf76124fdafe6fba2a">vhRenderPresentResult</a> (VkQueue presentQueue, VkSwapchainKHR swapChain, uint32_t imageIndex, VkSemaphore signalSemaphore)</td></tr>
<tr class="memdesc:a4390e33b2435fdbf76124fdafe6fba2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Present the result of a render operation to a window.  <a href="#a4390e33b2435fdbf76124fdafe6fba2a">More...</a><br /></td></tr>
<tr class="separator:a4390e33b2435fdbf76124fdafe6fba2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7ac38cec91ccc1cb7f7fc295735651"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#add7ac38cec91ccc1cb7f7fc295735651">vhPipeCreateGraphicsPipelineLayout</a> (VkDevice device, std::vector&lt; VkDescriptorSetLayout &gt; descriptorSetLayouts, std::vector&lt; VkPushConstantRange &gt; pushConstantRanges, VkPipelineLayout *pipelineLayout)</td></tr>
<tr class="memdesc:add7ac38cec91ccc1cb7f7fc295735651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pipeline layout for drawing a light pass.  <a href="#add7ac38cec91ccc1cb7f7fc295735651">More...</a><br /></td></tr>
<tr class="separator:add7ac38cec91ccc1cb7f7fc295735651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7b7ff0f821ebef5c91f82314ddd7da"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a1a7b7ff0f821ebef5c91f82314ddd7da">vhPipeCreateGraphicsPipeline</a> (VkDevice device, std::vector&lt; std::string &gt; shaderFileNames, VkExtent2D swapChainExtent, VkPipelineLayout pipelineLayout, VkRenderPass renderPass, std::vector&lt; VkDynamicState &gt; dynamicStates, VkPipeline *graphicsPipeline)</td></tr>
<tr class="memdesc:a1a7b7ff0f821ebef5c91f82314ddd7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pipeline state object (PSO) for a light pass.  <a href="#a1a7b7ff0f821ebef5c91f82314ddd7da">More...</a><br /></td></tr>
<tr class="separator:a1a7b7ff0f821ebef5c91f82314ddd7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abe327f01dff0d2f8af18263ee4b768"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a0abe327f01dff0d2f8af18263ee4b768">vhPipeCreateGraphicsShadowPipeline</a> (VkDevice device, std::string verShaderFilename, VkExtent2D shadowMapExtent, VkPipelineLayout pipelineLayout, VkRenderPass renderPass, VkPipeline *graphicsPipeline)</td></tr>
<tr class="memdesc:a0abe327f01dff0d2f8af18263ee4b768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pipeline state object (PSO) for a shadow pass.  <a href="#a0abe327f01dff0d2f8af18263ee4b768">More...</a><br /></td></tr>
<tr class="separator:a0abe327f01dff0d2f8af18263ee4b768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f76d8d8eeb5c06b7f55273a79d9830d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a5f76d8d8eeb5c06b7f55273a79d9830d">vhMemFindMemoryType</a> (VkPhysicalDevice physicalDevice, uint32_t typeFilter, VkMemoryPropertyFlags properties)</td></tr>
<tr class="memdesc:a5f76d8d8eeb5c06b7f55273a79d9830d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the right memory type.  <a href="#a5f76d8d8eeb5c06b7f55273a79d9830d">More...</a><br /></td></tr>
<tr class="separator:a5f76d8d8eeb5c06b7f55273a79d9830d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4f3634fb9f557f04f1a78824b22795"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#afb4f3634fb9f557f04f1a78824b22795">vhMemCreateVMAAllocator</a> (VkPhysicalDevice physicalDevice, VkDevice device, VmaAllocator &amp;allocator)</td></tr>
<tr class="memdesc:afb4f3634fb9f557f04f1a78824b22795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the VMA allocator library.  <a href="#afb4f3634fb9f557f04f1a78824b22795">More...</a><br /></td></tr>
<tr class="separator:afb4f3634fb9f557f04f1a78824b22795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7579b97116c0e15eecd4bd0ede9dea08"><td class="memItemLeft" align="right" valign="top">VkShaderModule&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a7579b97116c0e15eecd4bd0ede9dea08">vhPipeCreateShaderModule</a> (VkDevice device, const std::vector&lt; char &gt; &amp;code)</td></tr>
<tr class="memdesc:a7579b97116c0e15eecd4bd0ede9dea08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shader module.  <a href="#a7579b97116c0e15eecd4bd0ede9dea08">More...</a><br /></td></tr>
<tr class="separator:a7579b97116c0e15eecd4bd0ede9dea08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8becfa0316ca45ac8a219ce069aec09"><td class="memItemLeft" align="right" valign="top">VkSurfaceFormatKHR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ab8becfa0316ca45ac8a219ce069aec09">chooseSwapSurfaceFormat</a> (const std::vector&lt; VkSurfaceFormatKHR &gt; &amp;availableFormats)</td></tr>
<tr class="memdesc:ab8becfa0316ca45ac8a219ce069aec09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose swapchain format - try to use VK_FORMAT_B8G8R8A8_UNORM.  <a href="#ab8becfa0316ca45ac8a219ce069aec09">More...</a><br /></td></tr>
<tr class="separator:ab8becfa0316ca45ac8a219ce069aec09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fb86cff54a572754a511f5b3589c03"><td class="memItemLeft" align="right" valign="top">VkPresentModeKHR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#ac2fb86cff54a572754a511f5b3589c03">chooseSwapPresentMode</a> (const std::vector&lt; VkPresentModeKHR &gt; availablePresentModes)</td></tr>
<tr class="memdesc:ac2fb86cff54a572754a511f5b3589c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose the swapchain present mode - try to use Mailbox.  <a href="#ac2fb86cff54a572754a511f5b3589c03">More...</a><br /></td></tr>
<tr class="separator:ac2fb86cff54a572754a511f5b3589c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13205b72a90888bd5950d79fcbd529b6"><td class="memItemLeft" align="right" valign="top">VkExtent2D&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevh.html#a13205b72a90888bd5950d79fcbd529b6">chooseSwapExtent</a> (const VkSurfaceCapabilitiesKHR &amp;capabilities, VkExtent2D extent)</td></tr>
<tr class="memdesc:a13205b72a90888bd5950d79fcbd529b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose the 2D extent of the swapchain.  <a href="#a13205b72a90888bd5950d79fcbd529b6">More...</a><br /></td></tr>
<tr class="separator:a13205b72a90888bd5950d79fcbd529b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Vienna Vulkan Engine</p>
<p>(c) bei Helmut Hlavacs, University of Vienna </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a5b8c854df58e16a79055422d1b1f8516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8c854df58e16a79055422d1b1f8516">&#9670;&nbsp;</a></span>checkDeviceExtensionSupport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vh::checkDeviceExtensionSupport </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const char * &gt;&#160;</td>
          <td class="paramname"><em>requiredDeviceExtensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a given physical device offers a list of required extensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>A physical device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">requiredDeviceExtensions</td><td>A list with required device extensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the device supports all extensions or not </dd></dl>

</div>
</div>
<a id="a42616af40e6817b748d42deeda488618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42616af40e6817b748d42deeda488618">&#9670;&nbsp;</a></span>checkValidationLayerSupport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vh::checkValidationLayerSupport </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const char * &gt; &amp;&#160;</td>
          <td class="paramname"><em>validationLayers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check validation layers of the Vulkan instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">validationLayers</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all requested layers are supported by the device, else false </dd></dl>

</div>
</div>
<a id="a13205b72a90888bd5950d79fcbd529b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13205b72a90888bd5950d79fcbd529b6">&#9670;&nbsp;</a></span>chooseSwapExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkExtent2D vh::chooseSwapExtent </td>
          <td>(</td>
          <td class="paramtype">const VkSurfaceCapabilitiesKHR &amp;&#160;</td>
          <td class="paramname"><em>capabilities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkExtent2D&#160;</td>
          <td class="paramname"><em>extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose the 2D extent of the swapchain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capabilities</td><td>Capabilities of the window surface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extent</td><td>Extent of the window </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the chosen swapchain extent </dd></dl>

</div>
</div>
<a id="ac2fb86cff54a572754a511f5b3589c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fb86cff54a572754a511f5b3589c03">&#9670;&nbsp;</a></span>chooseSwapPresentMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkPresentModeKHR vh::chooseSwapPresentMode </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; VkPresentModeKHR &gt;&#160;</td>
          <td class="paramname"><em>availablePresentModes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose the swapchain present mode - try to use Mailbox. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">availablePresentModes</td><td>A list of available swap chain present modes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the chosen swapchain format </dd></dl>

</div>
</div>
<a id="ab8becfa0316ca45ac8a219ce069aec09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8becfa0316ca45ac8a219ce069aec09">&#9670;&nbsp;</a></span>chooseSwapSurfaceFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkSurfaceFormatKHR vh::chooseSwapSurfaceFormat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; VkSurfaceFormatKHR &gt; &amp;&#160;</td>
          <td class="paramname"><em>availableFormats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose swapchain format - try to use VK_FORMAT_B8G8R8A8_UNORM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">availableFormats</td><td>A list of available swap chain formats </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the chosen swapchain format </dd></dl>

</div>
</div>
<a id="a77a765fa525c8857895ba358996a2938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a765fa525c8857895ba358996a2938">&#9670;&nbsp;</a></span>hasStencilComponent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vh::hasStencilComponent </td>
          <td>(</td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether a depth image format supports stencil information </dd></dl>

</div>
</div>
<a id="a57c20b5524c517208b8984d3734f2aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c20b5524c517208b8984d3734f2aea">&#9670;&nbsp;</a></span>isDeviceSuitable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vh::isDeviceSuitable </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSurfaceKHR&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const char * &gt;&#160;</td>
          <td class="paramname"><em>requiredDeviceExtensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether a physical offers all required extensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>A physical device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surface</td><td>A window surface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">requiredDeviceExtensions</td><td>A list of required device extensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the device supports all required extensions or not </dd></dl>

</div>
</div>
<a id="a2dffa38557f5880ca9cedb269d3e45cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dffa38557f5880ca9cedb269d3e45cb">&#9670;&nbsp;</a></span>vhBufCopyBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhBufCopyBuffer </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>srcBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a buffer from a source buffer to a destination buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command bbuffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBuffer</td><td>Source buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstBuffer</td><td>Destination buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size in bytes of the data to be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c34f2bae24f3129f4c846227a336833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c34f2bae24f3129f4c846227a336833">&#9670;&nbsp;</a></span>vhBufCopyBufferToImage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhBufCopyBufferToImage </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a buffer to an image (for uploading via a staging buffer) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command buffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The source buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The destination image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layerCount</td><td>Number of layers in the image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Image width </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Image height </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac80851c019a6b6a029a08aeff02cf03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80851c019a6b6a029a08aeff02cf03f">&#9670;&nbsp;</a></span>vhBufCopyBufferToImage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhBufCopyBufferToImage </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkBufferImageCopy &gt; &amp;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for copying a buffer to an image, manages queue submission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command buffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The source buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The destination image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regions</td><td>The regions to be copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width of the image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Height of the image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa15b3523d6fa3fc5e3ba7c016a60472a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15b3523d6fa3fc5e3ba7c016a60472a">&#9670;&nbsp;</a></span>vhBufCopyImageToBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhBufCopyImageToBuffer </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageAspectFlagBits&#160;</td>
          <td class="paramname"><em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a VKImage to a VKBuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command buffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The source image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aspect</td><td>Aspect on how to use the image (color or depth) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The destination buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layerCount</td><td>Number of image layers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>mage width </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Image height </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a694a95f414d8bc28efcbbf667a7e58f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a694a95f414d8bc28efcbbf667a7e58f9">&#9670;&nbsp;</a></span>vhBufCopyImageToBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhBufCopyImageToBuffer </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkBufferImageCopy &gt; &amp;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a VKImage to a VKBuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command buffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The source image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The destination buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regions</td><td>Copy regions detailing the image parts that should be copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>mage width </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Image height </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0743986ab234bc389a6f3d2bef61a3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0743986ab234bc389a6f3d2bef61a3f7">&#9670;&nbsp;</a></span>vhBufCopyImageToHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhBufCopyImageToHost </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocator&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageAspectFlagBits&#160;</td>
          <td class="paramname"><em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gli::byte *&#160;</td>
          <td class="paramname"><em>bufferData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>imageSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a swap chain image to a data buffer, after it has been rendered into. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>VMA allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command buffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The source image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format of the image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aspect</td><td>Color or depth </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>The layout the image is currently in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferData</td><td>The destination buffer data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>mage width </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Image height </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imageSize</td><td>Size of the image in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6671c2b172d2263c11068f75ae423207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6671c2b172d2263c11068f75ae423207">&#9670;&nbsp;</a></span>vhBufCopySwapChainImageToHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhBufCopySwapChainImageToHost </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocator&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageAspectFlagBits&#160;</td>
          <td class="paramname"><em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gli::byte *&#160;</td>
          <td class="paramname"><em>bufferData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>imageSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a swap chain image to a data buffer, after it has been rendered into. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>VMA allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command buffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The source image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aspect</td><td>Color or depth </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferData</td><td>The destination buffer data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>mage width </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Image height </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imageSize</td><td>Size of the image in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86a2c772e5f54ed38ca9a14ee67ce2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a2c772e5f54ed38ca9a14ee67ce2ed">&#9670;&nbsp;</a></span>vhBufCreateBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhBufCreateBuffer </td>
          <td>(</td>
          <td class="paramtype">VmaAllocator&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBufferUsageFlags&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaMemoryUsage&#160;</td>
          <td class="paramname"><em>vmaUsage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocation *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Vulkan buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>VMA allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the buffer in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usage</td><td>Buffer usage flags </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vmaUsage</td><td>Usage for VMA </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The created buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allocation</td><td>The VMA allocation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28e43f0f3007c092b6cfea3b4d2eb925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e43f0f3007c092b6cfea3b4d2eb925">&#9670;&nbsp;</a></span>vhBufCreateDepthResources()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhBufCreateDepthResources </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocator&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkExtent2D&#160;</td>
          <td class="paramname"><em>extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>depthFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage *&#160;</td>
          <td class="paramname"><em>depthImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocation *&#160;</td>
          <td class="paramname"><em>depthImageAllocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageView *&#160;</td>
          <td class="paramname"><em>depthImageView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a depth image and a view to be used as depth map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>VMA allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command bbuffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extent</td><td>Extent of the swap chain images </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">depthFormat</td><td>Depth image format to be used for depth map </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">depthImage</td><td>Depth image to be used as depth map </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">depthImageAllocation</td><td>VMA allocation info </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">depthImageView</td><td>View of the depth image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54ba7ea8497eed149b5fda470cb71a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ba7ea8497eed149b5fda470cb71a78">&#9670;&nbsp;</a></span>vhBufCreateFramebuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhBufCreateFramebuffers </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkImageView &gt;&#160;</td>
          <td class="paramname"><em>imageViews</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkImageView &gt;&#160;</td>
          <td class="paramname"><em>depthImageViews</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkRenderPass&#160;</td>
          <td class="paramname"><em>renderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkExtent2D&#160;</td>
          <td class="paramname"><em>extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkFramebuffer &gt; &amp;&#160;</td>
          <td class="paramname"><em>frameBuffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create framebuffers (color + depth), one for each swap chain image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imageViews</td><td>Color images from the swap chain </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depthImageViews</td><td>List with views of the depth images </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">renderPass</td><td>Render pass to be used in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extent</td><td>Extent of the swap chain images </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">frameBuffers</td><td>The resulting frame buffers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f9240248076972838fd5410d4433b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9240248076972838fd5410d4433b8b">&#9670;&nbsp;</a></span>vhBufCreateImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhBufCreateImage </td>
          <td>(</td>
          <td class="paramtype">VmaAllocator&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>miplevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageTiling&#160;</td>
          <td class="paramname"><em>tiling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageUsageFlags&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageCreateFlags&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocation *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Vulkan image using VMA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Th VMA allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width of the image to be created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Height of the image to be created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">miplevels</td><td>Number of miplevels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayLayers</td><td>Number of image layers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Image format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tiling</td><td>Ho to layout the image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usage</td><td>Usage flags </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Create flags </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">image</td><td>The new image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allocation</td><td>VMA allocation information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5bbfc56732a182fe87f10ce967699ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bbfc56732a182fe87f10ce967699ed">&#9670;&nbsp;</a></span>vhBufCreateImageView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhBufCreateImageView </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageViewType&#160;</td>
          <td class="paramname"><em>viewtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageAspectFlags&#160;</td>
          <td class="paramname"><em>aspectFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageView *&#160;</td>
          <td class="paramname"><em>imageView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a view for a Vulkan image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The image for which the view is created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format of the image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewtype</td><td>Vulkan image view type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layerCount</td><td>Number of image layers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aspectFlags</td><td>Flags for how to use the view </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">imageView</td><td>The created image view </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fb318e83456d2b7f301ad3a5b1c5a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb318e83456d2b7f301ad3a5b1c5a07">&#9670;&nbsp;</a></span>vhBufCreateIndexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhBufCreateIndexBuffer </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocator&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer *&#160;</td>
          <td class="paramname"><em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocation *&#160;</td>
          <td class="paramname"><em>indexBufferAllocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Vulkan index buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>VMA allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command bbuffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indexBuffer</td><td>The new index buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indexBufferAllocation</td><td>VMA allocation information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7733e09fb0e2664562663d6a81874976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7733e09fb0e2664562663d6a81874976">&#9670;&nbsp;</a></span>vhBufCreateTexturecubeImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhBufCreateTexturecubeImage </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocator&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gli::texture_cube &amp;&#160;</td>
          <td class="paramname"><em>texCube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage *&#160;</td>
          <td class="paramname"><em>textureImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocation *&#160;</td>
          <td class="paramname"><em>textureImageAllocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat *&#160;</td>
          <td class="paramname"><em>pFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>VMA allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command bbuffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">texCube</td><td>The GLI cubemap information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">textureImage</td><td>The new image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">textureImageAllocation</td><td>VMA allocation information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pFormat</td><td>The image format (fixed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2615cec03ffb7297f65f9c485bb53d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2615cec03ffb7297f65f9c485bb53d2e">&#9670;&nbsp;</a></span>vhBufCreateTextureImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhBufCreateTextureImage </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocator&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>basedir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>texNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageCreateFlags&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage *&#160;</td>
          <td class="paramname"><em>textureImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocation *&#160;</td>
          <td class="paramname"><em>textureImageAllocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkExtent2D *&#160;</td>
          <td class="paramname"><em>extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a texture image from multiple files. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>The VMA allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command buffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basedir</td><td>Directoy the files are in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">texNames</td><td>List of file names holding the textures (should have same resolution) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Image create flags </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">textureImage</td><td>The new image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">textureImageAllocation</td><td>The VMA allocation info </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extent</td><td>The extent of the loaded image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9d7fe471ccd3e065a3e5e6117857e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d7fe471ccd3e065a3e5e6117857e8c">&#9670;&nbsp;</a></span>vhBufCreateTextureSampler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhBufCreateTextureSampler </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSampler *&#160;</td>
          <td class="paramname"><em>textureSampler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an image sampler for samplign textures in shaders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">textureSampler</td><td>The new sampler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5f24ff5c0c1d74b3ee1048d461690a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f24ff5c0c1d74b3ee1048d461690a0">&#9670;&nbsp;</a></span>vhBufCreateUniformBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhBufCreateUniformBuffers </td>
          <td>(</td>
          <td class="paramtype">VmaAllocator&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numberBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkBuffer &gt; &amp;&#160;</td>
          <td class="paramname"><em>uniformBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VmaAllocation &gt; &amp;&#160;</td>
          <td class="paramname"><em>uniformBuffersAllocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a UBO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>VMA allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numberBuffers</td><td>The number of UBOs to be created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of each new buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uniformBuffers</td><td>List containing the new buffers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uniformBuffersAllocation</td><td>VMA allocation information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90901f6f2cb0f3d551806520abce0dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90901f6f2cb0f3d551806520abce0dc8">&#9670;&nbsp;</a></span>vhBufCreateVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhBufCreateVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocator&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structvh_1_1vh_vertex.html">vh::vhVertex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer *&#160;</td>
          <td class="paramname"><em>vertexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocation *&#160;</td>
          <td class="paramname"><em>vertexBufferAllocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Vulkan vertex buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>VMA allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command bbuffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>List of vertices and their data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vertexBuffer</td><td>The new vertex buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vertexBufferAllocation</td><td>VMA allocation information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad28d13df6b14efaebef29dde2b1b7674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28d13df6b14efaebef29dde2b1b7674">&#9670;&nbsp;</a></span>vhBufTransitionImageLayout() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhBufTransitionImageLayout </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageAspectFlagBits&#160;</td>
          <td class="paramname"><em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>miplevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>oldLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>newLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transition the image layout, causes a pipeline barrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command buffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The destination image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>The Image format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aspect</td><td>Color or depth </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">miplevels</td><td>Number of image miplevels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layerCount</td><td>Number of image layers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oldLayout</td><td>Old layout of the image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newLayout</td><td>The layout should be transitioned to this new layout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71f3a6b1cca391a5c133f8026c0d7d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f3a6b1cca391a5c133f8026c0d7d81">&#9670;&nbsp;</a></span>vhBufTransitionImageLayout() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhBufTransitionImageLayout </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageAspectFlagBits&#160;</td>
          <td class="paramname"><em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>miplevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>oldLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>newLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transition the image layout, causes a pipeline barrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Device queue for submitting commands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Command buffer to record this operation into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The destination image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>The Image format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aspect</td><td>Color or depth </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">miplevels</td><td>Number of image miplevels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layerCount</td><td>Number of image layers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oldLayout</td><td>Old layout of the image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newLayout</td><td>The layout should be transitioned to this new layout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72b5d170d3b735ede6a6f57806402ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b5d170d3b735ede6a6f57806402ad1">&#9670;&nbsp;</a></span>vhCmdBeginSingleTimeCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkCommandBuffer vh::vhCmdBeginSingleTimeCommands </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin submitting a single time command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Command pool for allocating command bbuffers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new VkCommandBuffer to record commands into </dd></dl>

</div>
</div>
<a id="a75a61b7e654b90be1ff704e4cfbd6f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a61b7e654b90be1ff704e4cfbd6f77">&#9670;&nbsp;</a></span>vhCmdCreateCommandPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhCmdCreateCommandPool </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSurfaceKHR&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool *&#160;</td>
          <td class="paramname"><em>commandPool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new command pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physicalDevice</td><td>Physical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surface</td><td>Window surface - Needed for finding the right queue families </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">commandPool</td><td>New command pool for allocating command bbuffers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3561c11e98c2d5ba6fc7a2b53a45ac48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3561c11e98c2d5ba6fc7a2b53a45ac48">&#9670;&nbsp;</a></span>vhCmdEndSingleTimeCommands() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhCmdEndSingleTimeCommands </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>commandBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End recording into a single time command buffer and submit it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Queue to submit the buffer to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Give back the command buffer to the pool </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>The ready to be used command buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3500d2b026ba0e56835f14742b59d160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3500d2b026ba0e56835f14742b59d160">&#9670;&nbsp;</a></span>vhCmdEndSingleTimeCommands() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhCmdEndSingleTimeCommands </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSemaphore&#160;</td>
          <td class="paramname"><em>waitSemaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSemaphore&#160;</td>
          <td class="paramname"><em>signalSemaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFence&#160;</td>
          <td class="paramname"><em>waitFence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End recording into a single time command buffer and submit it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graphicsQueue</td><td>Queue to submit the buffer to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandPool</td><td>Give back the command buffer to the pool </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>The ready to be used command buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waitSemaphore</td><td>A semaphore to wait for before submitting </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signalSemaphore</td><td>Signal this semaphore after buffer is done </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waitFence</td><td>Signal to this fence after buffer is done </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a451d818d1649c7341bbb892953716573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451d818d1649c7341bbb892953716573">&#9670;&nbsp;</a></span>vhDevCreateInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhDevCreateInstance </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const char * &gt; &amp;&#160;</td>
          <td class="paramname"><em>extensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const char * &gt; &amp;&#160;</td>
          <td class="paramname"><em>validationLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkInstance *&#160;</td>
          <td class="paramname"><em>instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Vulkan instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">extensions</td><td>Requested layers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">validationLayers</td><td>Requested validation layers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">instance</td><td>The new instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VkResult of the operation </dd></dl>

</div>
</div>
<a id="a20cb3a4423dcb39d177d382c4834a396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20cb3a4423dcb39d177d382c4834a396">&#9670;&nbsp;</a></span>vhDevCreateLogicalDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhDevCreateLogicalDevice </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSurfaceKHR&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const char * &gt;&#160;</td>
          <td class="paramname"><em>requiredDeviceExtensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const char * &gt;&#160;</td>
          <td class="paramname"><em>requiredValidationLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDevice *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue *&#160;</td>
          <td class="paramname"><em>graphicsQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue *&#160;</td>
          <td class="paramname"><em>presentQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a logical device and according queues. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physicalDevice</td><td>The physical device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surface</td><td>Window surface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">requiredDeviceExtensions</td><td>List of required device extensions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">requiredValidationLayers</td><td>List of required validation layers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">device</td><td>The new logical device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">graphicsQueue</td><td>A graphics queue into the device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">presentQueue</td><td>A present queue into the device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c544f8c40f982eec87405acf83ce225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c544f8c40f982eec87405acf83ce225">&#9670;&nbsp;</a></span>vhDevFindDepthFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkFormat vh::vhDevFindDepthFormat </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>physicalDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a suitable format for the depth/stencil buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physicalDevice</td><td>The physical device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a suitable format that is supported by the physical device </dd></dl>

</div>
</div>
<a id="a8c3bbcd70fcf52ed6b19e0d72b75b2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3bbcd70fcf52ed6b19e0d72b75b2b4">&#9670;&nbsp;</a></span>vhDevFindQueueFamilies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvh_1_1_queue_family_indices.html">QueueFamilyIndices</a> vh::vhDevFindQueueFamilies </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSurfaceKHR&#160;</td>
          <td class="paramname"><em>surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find suitable queue families of a given physical device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>A physical device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surface</td><td>The surface of a window </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a structure containing queue family indices of suitable families </dd></dl>

</div>
</div>
<a id="a81c685442b0d3f4a3dc89177f8d6f11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c685442b0d3f4a3dc89177f8d6f11b">&#9670;&nbsp;</a></span>vhDevFindSupportedFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkFormat vh::vhDevFindSupportedFormat </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; VkFormat &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageTiling&#160;</td>
          <td class="paramname"><em>tiling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormatFeatureFlags&#160;</td>
          <td class="paramname"><em>features</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query a suitable image format that the device supports. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physicalDevice</td><td>The physical device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">candidates</td><td>A list with candidate formats </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tiling</td><td>Linear or optimal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">features</td><td>Usage of the format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a suitable format that is supported by the physical device </dd></dl>

</div>
</div>
<a id="a6875d8352834932f9990c7bfb72be6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6875d8352834932f9990c7bfb72be6aa">&#9670;&nbsp;</a></span>vhDevPickPhysicalDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhDevPickPhysicalDevice </td>
          <td>(</td>
          <td class="paramtype">VkInstance&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSurfaceKHR&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const char * &gt;&#160;</td>
          <td class="paramname"><em>requiredDeviceExtensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPhysicalDevice *&#160;</td>
          <td class="paramname"><em>physicalDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether a physical offers all required extensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>The Vulkan instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surface</td><td>A window surface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">requiredDeviceExtensions</td><td>A list of required device extensions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">physicalDevice</td><td>A physical device that supports all required extensions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af70e43347ac845d3a98dd5a3ac36bf11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70e43347ac845d3a98dd5a3ac36bf11">&#9670;&nbsp;</a></span>vhDevQuerySwapChainSupport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvh_1_1_swap_chain_support_details.html">SwapChainSupportDetails</a> vh::vhDevQuerySwapChainSupport </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSurfaceKHR&#160;</td>
          <td class="paramname"><em>surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query which swap chains a physical device supports. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>A physical device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surface</td><td>A window surface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a structure holding details about capabilities, formats and present modes offered by the device </dd></dl>

</div>
</div>
<a id="a3e1916a9160bee6b83f7f9effd3cdd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1916a9160bee6b83f7f9effd3cdd34">&#9670;&nbsp;</a></span>vhFileRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; char &gt; vh::vhFileRead </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the contents of a file and return a binary blob with it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Filename </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a binary blob containing the file. </dd></dl>

</div>
</div>
<a id="afb4f3634fb9f557f04f1a78824b22795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4f3634fb9f557f04f1a78824b22795">&#9670;&nbsp;</a></span>vhMemCreateVMAAllocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhMemCreateVMAAllocator </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VmaAllocator &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the VMA allocator library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physicalDevice</td><td>Physical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allocator</td><td>The created VMA allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f76d8d8eeb5c06b7f55273a79d9830d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f76d8d8eeb5c06b7f55273a79d9830d">&#9670;&nbsp;</a></span>vhMemFindMemoryType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vh::vhMemFindMemoryType </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>typeFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkMemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the right memory type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physicalDevice</td><td>Physical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">typeFilter</td><td>Memory type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">properties</td><td>Desired memory properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of memory heap that fulfills the properties </dd></dl>

</div>
</div>
<a id="a1a7b7ff0f821ebef5c91f82314ddd7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7b7ff0f821ebef5c91f82314ddd7da">&#9670;&nbsp;</a></span>vhPipeCreateGraphicsPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhPipeCreateGraphicsPipeline </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>shaderFileNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkExtent2D&#160;</td>
          <td class="paramname"><em>swapChainExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipelineLayout&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkRenderPass&#160;</td>
          <td class="paramname"><em>renderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkDynamicState &gt;&#160;</td>
          <td class="paramname"><em>dynamicStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipeline *&#160;</td>
          <td class="paramname"><em>graphicsPipeline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pipeline state object (PSO) for a light pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shaderFileNames</td><td>List of filenames for the shaders: vertex, fragment, geometry, tess control, tess eval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swapChainExtent</td><td>Swapchain extent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pipelineLayout</td><td>Pipeline layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">renderPass</td><td>Renderpass to be used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dynamicStates</td><td>List of dynamic states that can be changed during usage of the pipeline </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">graphicsPipeline</td><td>The new PSO </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>in VkResult </dd></dl>

</div>
</div>
<a id="add7ac38cec91ccc1cb7f7fc295735651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7ac38cec91ccc1cb7f7fc295735651">&#9670;&nbsp;</a></span>vhPipeCreateGraphicsPipelineLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhPipeCreateGraphicsPipelineLayout </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkDescriptorSetLayout &gt;&#160;</td>
          <td class="paramname"><em>descriptorSetLayouts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkPushConstantRange &gt;&#160;</td>
          <td class="paramname"><em>pushConstantRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipelineLayout *&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pipeline layout for drawing a light pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptorSetLayouts</td><td>Descriptor set layouts </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pushConstantRanges</td><td>A list with push constant ranges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pipelineLayout</td><td>Resulting pipline layout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>in VkResult </dd></dl>

</div>
</div>
<a id="a0abe327f01dff0d2f8af18263ee4b768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abe327f01dff0d2f8af18263ee4b768">&#9670;&nbsp;</a></span>vhPipeCreateGraphicsShadowPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhPipeCreateGraphicsShadowPipeline </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>verShaderFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkExtent2D&#160;</td>
          <td class="paramname"><em>shadowMapExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipelineLayout&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkRenderPass&#160;</td>
          <td class="paramname"><em>renderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipeline *&#160;</td>
          <td class="paramname"><em>graphicsPipeline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pipeline state object (PSO) for a shadow pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verShaderFilename</td><td>Name of the vetex shader file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shadowMapExtent</td><td>Swapchain extent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pipelineLayout</td><td>Pipeline layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">renderPass</td><td>Renderpass to be used </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">graphicsPipeline</td><td>The new PSO </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>in VkResult </dd></dl>

</div>
</div>
<a id="a7579b97116c0e15eecd4bd0ede9dea08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7579b97116c0e15eecd4bd0ede9dea08">&#9670;&nbsp;</a></span>vhPipeCreateShaderModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkShaderModule vh::vhPipeCreateShaderModule </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a shader module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>Blob of bytes that hold the SPIR-V shader code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shader module </dd></dl>

</div>
</div>
<a id="ad33a812099efdb28335db179ab789fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33a812099efdb28335db179ab789fd2">&#9670;&nbsp;</a></span>vhRenderBeginRenderPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhRenderBeginRenderPass </td>
          <td>(</td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkRenderPass&#160;</td>
          <td class="paramname"><em>renderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFramebuffer&#160;</td>
          <td class="paramname"><em>frameBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkExtent2D&#160;</td>
          <td class="paramname"><em>extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start rendering in a command buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>The command buffer to record into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">renderPass</td><td>The render pass that should be begun </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frameBuffer</td><td>The framebuffer for the render pass </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extent</td><td>Extent of the framebuffer images </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55ec1b174dce07cb9947b055c354b179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ec1b174dce07cb9947b055c354b179">&#9670;&nbsp;</a></span>vhRenderBeginRenderPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhRenderBeginRenderPass </td>
          <td>(</td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkRenderPass&#160;</td>
          <td class="paramname"><em>renderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFramebuffer&#160;</td>
          <td class="paramname"><em>frameBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkClearValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>clearValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkExtent2D&#160;</td>
          <td class="paramname"><em>extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start rendering in a command buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>The command buffer to record into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">renderPass</td><td>The render pass that should be begun </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frameBuffer</td><td>The framebuffer for the render pass </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clearValues</td><td>A list of clear values to clear render targets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extent</td><td>Extent of the framebuffer images </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8f31a918822c6b09d118611bc4e629c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f31a918822c6b09d118611bc4e629c">&#9670;&nbsp;</a></span>vhRenderCreateDescriptorPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhRenderCreateDescriptorPool </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkDescriptorType &gt;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>numberDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDescriptorPool *&#160;</td>
          <td class="paramname"><em>descriptorPool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a descriptor pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>The logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">types</td><td>Contains the resource types in the pool </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numberDesc</td><td>Denotes how many of them are in the pool </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">descriptorPool</td><td>The new descriptor pool </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf5951d9e013d1bd9fdab39b2ee4516d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5951d9e013d1bd9fdab39b2ee4516d">&#9670;&nbsp;</a></span>vhRenderCreateDescriptorSetLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhRenderCreateDescriptorSetLayout </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkDescriptorType &gt;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkShaderStageFlags &gt;&#160;</td>
          <td class="paramname"><em>stageFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDescriptorSetLayout *&#160;</td>
          <td class="paramname"><em>descriptorSetLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a descriptor layout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>The logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counts</td><td>The number of images in an array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">types</td><td>Contains the resource types for the increasing bindings </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stageFlags</td><td>Denotes in which stages they should be used </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">descriptorSetLayout</td><td>The new descriptor set layout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f0c05cca7c6f71779e85f10e25c3878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0c05cca7c6f71779e85f10e25c3878">&#9670;&nbsp;</a></span>vhRenderCreateDescriptorSets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhRenderCreateDescriptorSets </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numberDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDescriptorSetLayout&#160;</td>
          <td class="paramname"><em>descriptorSetLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDescriptorPool&#160;</td>
          <td class="paramname"><em>descriptorPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkDescriptorSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>descriptorSets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a number of descriptor sets, one for each frame in the swapchain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>The logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numberDesc</td><td>Number of sets to be created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptorSetLayout</td><td>The layout for the set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptorPool</td><td>The pool from which the set is drawn </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">descriptorSets</td><td>The new descriptor sets </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e955c65e9f1dd327237cacf2439d81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e955c65e9f1dd327237cacf2439d81f">&#9670;&nbsp;</a></span>vhRenderCreateRenderPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhRenderCreateRenderPass </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>swapChainImageFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>depthFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkAttachmentLoadOp&#160;</td>
          <td class="paramname"><em>loadOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkRenderPass *&#160;</td>
          <td class="paramname"><em>renderPass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a render pass for a light pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>The logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swapChainImageFormat</td><td>The swap chain image format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depthFormat</td><td>The depth map image format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">loadOp</td><td>Operation what to do with the framebuffer when starting the render pass: clear, keep, or dont care </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">renderPass</td><td>The new render pass </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc1d99ade9bdbbdcb607bcb54dfac0c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1d99ade9bdbbdcb607bcb54dfac0c8">&#9670;&nbsp;</a></span>vhRenderCreateRenderPassShadow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhRenderCreateRenderPassShadow </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>depthFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkRenderPass *&#160;</td>
          <td class="paramname"><em>renderPass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a render pass for a shadow pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>The logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depthFormat</td><td>The depth map image format </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">renderPass</td><td>The new render pass </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4390e33b2435fdbf76124fdafe6fba2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4390e33b2435fdbf76124fdafe6fba2a">&#9670;&nbsp;</a></span>vhRenderPresentResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vh::vhRenderPresentResult </td>
          <td>(</td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>presentQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSwapchainKHR&#160;</td>
          <td class="paramname"><em>swapChain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>imageIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSemaphore&#160;</td>
          <td class="paramname"><em>signalSemaphore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Present the result of a render operation to a window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">presentQueue</td><td>The present queue that the image is sent to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swapChain</td><td>The Vulkan swap chain </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imageIndex</td><td>Index of the swap chain image currently used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signalSemaphore</td><td>Semaphore that should be signaled once the operation is done </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c13ad01667cf5bc7c0946bdc61b53b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c13ad01667cf5bc7c0946bdc61b53b8">&#9670;&nbsp;</a></span>vhRenderUpdateDescriptorSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhRenderUpdateDescriptorSet </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDescriptorSet&#160;</td>
          <td class="paramname"><em>descriptorSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkBuffer &gt;&#160;</td>
          <td class="paramname"><em>uniformBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>bufferRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; VkImageView &gt;&gt;&#160;</td>
          <td class="paramname"><em>textureImageViews</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; VkSampler &gt;&gt;&#160;</td>
          <td class="paramname"><em>textureSamplers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a descriptor set. </p>
<p>Since it can contain variable number of resources, the lists contain either uniformBuffers or imageViews/sampler. The size of the lists MUST be the same!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical Vulkan device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptorSet</td><td>The descriptor set to be updated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uniformBuffers</td><td>List of UBOs (can contain null handles) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferRanges</td><td>List of buffer sizes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">textureImageViews</td><td>List of texture image views to be updated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">textureSamplers</td><td>List of texture image samplers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0401ce1a7329f9b52497fff549135f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0401ce1a7329f9b52497fff549135f7a">&#9670;&nbsp;</a></span>vhSwapCreateSwapChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vh::vhSwapCreateSwapChain </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSurfaceKHR&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkExtent2D&#160;</td>
          <td class="paramname"><em>frameBufferExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSwapchainKHR *&#160;</td>
          <td class="paramname"><em>swapChain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkImage &gt; &amp;&#160;</td>
          <td class="paramname"><em>swapChainImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VkImageView &gt; &amp;&#160;</td>
          <td class="paramname"><em>swapChainImageViews</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat *&#160;</td>
          <td class="paramname"><em>swapChainImageFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkExtent2D *&#160;</td>
          <td class="paramname"><em>swapChainExtent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose the swapchain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physicalDevice</td><td>The physical device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surface</td><td>The window surface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Logical device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frameBufferExtent</td><td>Extent of the framebuffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">swapChain</td><td>The new swapchain </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">swapChainImages</td><td>A list containing the swapchain images </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">swapChainImageViews</td><td>A list containing swapchain image views </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">swapChainImageFormat</td><td>A list containing swapchain image formats </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">swapChainExtent</td><td>Swapchain extent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 19 2019 20:48:01 for Vienna Vulkan Engine by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
