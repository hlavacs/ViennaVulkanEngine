<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vienna Vulkan Engine: ve::VESceneManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vienna Vulkan Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceve.html">ve</a></li><li class="navelem"><a class="el" href="classve_1_1_v_e_scene_manager.html">VESceneManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classve_1_1_v_e_scene_manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ve::VESceneManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The scene Manager manages the objects that have been loaded and put into the world.  
 <a href="classve_1_1_v_e_scene_manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_v_e_scene_manager_8h_source.html">VESceneManager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab734ad6953897388d0bc7ee22369ed3b"><td class="memItemLeft" align="right" valign="top"><a id="ab734ad6953897388d0bc7ee22369ed3b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#ab734ad6953897388d0bc7ee22369ed3b">VESceneManager</a> ()</td></tr>
<tr class="memdesc:ab734ad6953897388d0bc7ee22369ed3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of class <a class="el" href="classve_1_1_v_e_scene_manager.html" title="The scene Manager manages the objects that have been loaded and put into the world.">VESceneManager</a>. <br /></td></tr>
<tr class="separator:ab734ad6953897388d0bc7ee22369ed3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b77d8fc900cdc268ef92dcdfad20ae"><td class="memItemLeft" align="right" valign="top"><a id="a63b77d8fc900cdc268ef92dcdfad20ae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a63b77d8fc900cdc268ef92dcdfad20ae">~VESceneManager</a> ()</td></tr>
<tr class="memdesc:a63b77d8fc900cdc268ef92dcdfad20ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of class <a class="el" href="classve_1_1_v_e_scene_manager.html" title="The scene Manager manages the objects that have been loaded and put into the world.">VESceneManager</a>. <br /></td></tr>
<tr class="separator:a63b77d8fc900cdc268ef92dcdfad20ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb42fdaf90df123a6fa6364191d0656b"><td class="memItemLeft" align="right" valign="top">const aiScene *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#afb42fdaf90df123a6fa6364191d0656b">loadAssets</a> (std::string basedir, std::string filename, uint32_t aiFlags, std::vector&lt; <a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> * &gt; &amp;meshes, std::vector&lt; <a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> * &gt; &amp;materials)</td></tr>
<tr class="memdesc:afb42fdaf90df123a6fa6364191d0656b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load assets from file ussing Assimp.  <a href="#afb42fdaf90df123a6fa6364191d0656b">More...</a><br /></td></tr>
<tr class="separator:afb42fdaf90df123a6fa6364191d0656b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dffe81f507aafc98ce88bde78f7c61a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a0dffe81f507aafc98ce88bde78f7c61a">createMeshes</a> (const aiScene *pScene, std::string filekey, std::vector&lt; <a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> * &gt; &amp;meshes)</td></tr>
<tr class="memdesc:a0dffe81f507aafc98ce88bde78f7c61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create all <a class="el" href="classve_1_1_v_e_mesh.html" title="Store a mesh in a Vulkan vertex and index buffer.">VEMesh</a> instances from a file loaded by Assimp.  <a href="#a0dffe81f507aafc98ce88bde78f7c61a">More...</a><br /></td></tr>
<tr class="separator:a0dffe81f507aafc98ce88bde78f7c61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cb40d0509a6db4730d8204d08a8c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a40cb40d0509a6db4730d8204d08a8c12">createMaterials</a> (const aiScene *pScene, std::string basedir, std::string filekey, std::vector&lt; <a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> * &gt; &amp;materials)</td></tr>
<tr class="memdesc:a40cb40d0509a6db4730d8204d08a8c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create all <a class="el" href="classve_1_1_v_e_material.html" title="Store material data.">VEMaterial</a> instances from a file loaded by Assimp.  <a href="#a40cb40d0509a6db4730d8204d08a8c12">More...</a><br /></td></tr>
<tr class="separator:a40cb40d0509a6db4730d8204d08a8c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f329338bd5b87cbdacf86264179b96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a92f329338bd5b87cbdacf86264179b96">loadModel</a> (std::string entityName, std::string basedir, std::string filename, uint32_t aiFlags=0, <a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *parent=nullptr)</td></tr>
<tr class="memdesc:a92f329338bd5b87cbdacf86264179b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load assets from file ussing Assimp, create entities from them.  <a href="#a92f329338bd5b87cbdacf86264179b96">More...</a><br /></td></tr>
<tr class="separator:a92f329338bd5b87cbdacf86264179b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360348074bc1b7258ebac56c427c52c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a360348074bc1b7258ebac56c427c52c3">createSceneNode</a> (std::string name, glm::mat4 transf=glm::mat4(1.0f), VESceneNode *parent=nullptr)</td></tr>
<tr class="memdesc:a360348074bc1b7258ebac56c427c52c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a scene node.  <a href="#a360348074bc1b7258ebac56c427c52c3">More...</a><br /></td></tr>
<tr class="separator:a360348074bc1b7258ebac56c427c52c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d07f4374b091bffc885f272ac1bf5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_entity.html">VEEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a11d07f4374b091bffc885f272ac1bf5f">createEntity</a> (std::string entityName, <a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> *pMesh, <a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> *pMat, glm::mat4 transf, <a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *parent=nullptr)</td></tr>
<tr class="memdesc:a11d07f4374b091bffc885f272ac1bf5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an entity.  <a href="#a11d07f4374b091bffc885f272ac1bf5f">More...</a><br /></td></tr>
<tr class="separator:a11d07f4374b091bffc885f272ac1bf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9773c6d25c6fa5ea849fe393bb8e7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_entity.html">VEEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a9e9773c6d25c6fa5ea849fe393bb8e7b">createEntity</a> (std::string entityName, <a class="el" href="classve_1_1_v_e_entity.html#a2c7f15fd3b11aac4dea3e76cfa508010">VEEntity::veEntityType</a> type, <a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> *pMesh, <a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> *pMat, glm::mat4 transf, <a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *parent=nullptr)</td></tr>
<tr class="memdesc:a9e9773c6d25c6fa5ea849fe393bb8e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an entity.  <a href="#a9e9773c6d25c6fa5ea849fe393bb8e7b">More...</a><br /></td></tr>
<tr class="separator:a9e9773c6d25c6fa5ea849fe393bb8e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a05a9c4236e5aa2a2140f172bd4f6b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a6a05a9c4236e5aa2a2140f172bd4f6b1">createCubemap</a> (std::string entityName, std::string basedir, std::string filename)</td></tr>
<tr class="memdesc:a6a05a9c4236e5aa2a2140f172bd4f6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a cube map based sky box.  <a href="#a6a05a9c4236e5aa2a2140f172bd4f6b1">More...</a><br /></td></tr>
<tr class="separator:a6a05a9c4236e5aa2a2140f172bd4f6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22900dda5097a091f671992599a5a826"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a22900dda5097a091f671992599a5a826">createCubemap</a> (std::string entityName, std::string basedir, std::vector&lt; std::string &gt; filenames)</td></tr>
<tr class="memdesc:a22900dda5097a091f671992599a5a826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a cube map based sky box.  <a href="#a22900dda5097a091f671992599a5a826">More...</a><br /></td></tr>
<tr class="separator:a22900dda5097a091f671992599a5a826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733b1cdeac84abc64ede58ac22d61021"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_entity.html">VEEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a733b1cdeac84abc64ede58ac22d61021">createSkyplane</a> (std::string entityName, std::string basedir, std::string texName)</td></tr>
<tr class="memdesc:a733b1cdeac84abc64ede58ac22d61021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a plane that is projected to the far plane of the frustum.  <a href="#a733b1cdeac84abc64ede58ac22d61021">More...</a><br /></td></tr>
<tr class="separator:a733b1cdeac84abc64ede58ac22d61021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae47277fd521d322ee02dc51f643e7f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#aae47277fd521d322ee02dc51f643e7f8">createSkybox</a> (std::string entityName, std::string basedir, std::vector&lt; std::string &gt; texNames)</td></tr>
<tr class="memdesc:aae47277fd521d322ee02dc51f643e7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a skyplane based sky box.  <a href="#aae47277fd521d322ee02dc51f643e7f8">More...</a><br /></td></tr>
<tr class="separator:aae47277fd521d322ee02dc51f643e7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1d754eb2b772fdd7d1fc7bc8d94625"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a0f1d754eb2b772fdd7d1fc7bc8d94625">getRootSceneNode</a> ()</td></tr>
<tr class="separator:a0f1d754eb2b772fdd7d1fc7bc8d94625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ab8c69e5ea095eb394166db5b246bf"><td class="memItemLeft" align="right" valign="top"><a id="ac0ab8c69e5ea095eb394166db5b246bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#ac0ab8c69e5ea095eb394166db5b246bf">sceneGraphChanged</a> ()</td></tr>
<tr class="memdesc:ac0ab8c69e5ea095eb394166db5b246bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This should be called whenever the scene graph ist changed. <br /></td></tr>
<tr class="separator:ac0ab8c69e5ea095eb394166db5b246bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadccc0f574cd30019e940ab56acc832"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#aaadccc0f574cd30019e940ab56acc832">updateSceneNodes</a> (uint32_t imageIndex)</td></tr>
<tr class="memdesc:aaadccc0f574cd30019e940ab56acc832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all scene nodes without a parent, then update them and their children.  <a href="#aaadccc0f574cd30019e940ab56acc832">More...</a><br /></td></tr>
<tr class="separator:aaadccc0f574cd30019e940ab56acc832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a142d8ebce07b6f149fbe8fd8647df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a18a142d8ebce07b6f149fbe8fd8647df">addSceneNode</a> (<a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *entity)</td></tr>
<tr class="memdesc:a18a142d8ebce07b6f149fbe8fd8647df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new scene node into the scene.  <a href="#a18a142d8ebce07b6f149fbe8fd8647df">More...</a><br /></td></tr>
<tr class="separator:a18a142d8ebce07b6f149fbe8fd8647df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22dd9760111ca205cf97b2fdcfdbb6d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a22dd9760111ca205cf97b2fdcfdbb6d7">getSceneNode</a> (std::string entityName)</td></tr>
<tr class="memdesc:a22dd9760111ca205cf97b2fdcfdbb6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an entity using its name.  <a href="#a22dd9760111ca205cf97b2fdcfdbb6d7">More...</a><br /></td></tr>
<tr class="separator:a22dd9760111ca205cf97b2fdcfdbb6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4964068bea04034d723881b7551dd597"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a4964068bea04034d723881b7551dd597">deleteSceneNodeAndChildren</a> (std::string name)</td></tr>
<tr class="memdesc:a4964068bea04034d723881b7551dd597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an entity and all its subentities.  <a href="#a4964068bea04034d723881b7551dd597">More...</a><br /></td></tr>
<tr class="separator:a4964068bea04034d723881b7551dd597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af429201487fd4e085080ed3fc839a8ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#af429201487fd4e085080ed3fc839a8ea">createSceneNodeList</a> (<a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *pObject, std::vector&lt; std::string &gt; &amp;namelist)</td></tr>
<tr class="memdesc:af429201487fd4e085080ed3fc839a8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a list of all child entities of a given entity.  <a href="#af429201487fd4e085080ed3fc839a8ea">More...</a><br /></td></tr>
<tr class="separator:af429201487fd4e085080ed3fc839a8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78127a3b00123f8a108c4eeda09cc1f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a78127a3b00123f8a108c4eeda09cc1f8">getMesh</a> (std::string name)</td></tr>
<tr class="memdesc:a78127a3b00123f8a108c4eeda09cc1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a mesh by its name and return a pointer to it.  <a href="#a78127a3b00123f8a108c4eeda09cc1f8">More...</a><br /></td></tr>
<tr class="separator:a78127a3b00123f8a108c4eeda09cc1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ecc663dc2570d4c54b2e36529deb5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a88ecc663dc2570d4c54b2e36529deb5c">deleteMesh</a> (std::string name)</td></tr>
<tr class="memdesc:a88ecc663dc2570d4c54b2e36529deb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a mesh given its name.  <a href="#a88ecc663dc2570d4c54b2e36529deb5c">More...</a><br /></td></tr>
<tr class="separator:a88ecc663dc2570d4c54b2e36529deb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08774600d83d1e2cdecdc2ca1bafc6de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a08774600d83d1e2cdecdc2ca1bafc6de">getMaterial</a> (std::string name)</td></tr>
<tr class="memdesc:a08774600d83d1e2cdecdc2ca1bafc6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a material by its name and return a pointer to it.  <a href="#a08774600d83d1e2cdecdc2ca1bafc6de">More...</a><br /></td></tr>
<tr class="separator:a08774600d83d1e2cdecdc2ca1bafc6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ca7fe353361e0da3ee4a850f57d3ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a16ca7fe353361e0da3ee4a850f57d3ce">deleteMaterial</a> (std::string name)</td></tr>
<tr class="memdesc:a16ca7fe353361e0da3ee4a850f57d3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a material given its name.  <a href="#a16ca7fe353361e0da3ee4a850f57d3ce">More...</a><br /></td></tr>
<tr class="separator:a16ca7fe353361e0da3ee4a850f57d3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dedc85430da2d06259704f47ec4f3c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_camera.html">VECamera</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a6dedc85430da2d06259704f47ec4f3c7">getCamera</a> ()</td></tr>
<tr class="separator:a6dedc85430da2d06259704f47ec4f3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acedf235e65ee027a0df5dc92163fcefe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#acedf235e65ee027a0df5dc92163fcefe">setCamera</a> (<a class="el" href="classve_1_1_v_e_camera.html">VECamera</a> *cam)</td></tr>
<tr class="memdesc:acedf235e65ee027a0df5dc92163fcefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the the current camera.  <a href="#acedf235e65ee027a0df5dc92163fcefe">More...</a><br /></td></tr>
<tr class="separator:acedf235e65ee027a0df5dc92163fcefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e8d10dcab7cce48b9b5c28acda0ead"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classve_1_1_v_e_light.html">VELight</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#ad5e8d10dcab7cce48b9b5c28acda0ead">getLights</a> ()</td></tr>
<tr class="separator:ad5e8d10dcab7cce48b9b5c28acda0ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5a46bc9fb0c998451b96b68dcbf45d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a3c5a46bc9fb0c998451b96b68dcbf45d">switchOnLight</a> (<a class="el" href="classve_1_1_v_e_light.html">VELight</a> *light)</td></tr>
<tr class="memdesc:a3c5a46bc9fb0c998451b96b68dcbf45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a light to the m_lights list, thus switching it on.  <a href="#a3c5a46bc9fb0c998451b96b68dcbf45d">More...</a><br /></td></tr>
<tr class="separator:a3c5a46bc9fb0c998451b96b68dcbf45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d225517b9db68a1d93769bf72fb5e7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a8d225517b9db68a1d93769bf72fb5e7b">switchOffLight</a> (<a class="el" href="classve_1_1_v_e_light.html">VELight</a> *light)</td></tr>
<tr class="memdesc:a8d225517b9db68a1d93769bf72fb5e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a light from the m_lights list, thus switching it off.  <a href="#a8d225517b9db68a1d93769bf72fb5e7b">More...</a><br /></td></tr>
<tr class="separator:a8d225517b9db68a1d93769bf72fb5e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f64a8b8e2fbb1528cba99c6714fb20"><td class="memItemLeft" align="right" valign="top"><a id="ab8f64a8b8e2fbb1528cba99c6714fb20"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#ab8f64a8b8e2fbb1528cba99c6714fb20">printSceneNodes</a> ()</td></tr>
<tr class="memdesc:ab8f64a8b8e2fbb1528cba99c6714fb20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a list of all entities to the console. <br /></td></tr>
<tr class="separator:ab8f64a8b8e2fbb1528cba99c6714fb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59e458ea6b4d9ab6ceadfb0213f5f49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#af59e458ea6b4d9ab6ceadfb0213f5f49">printTree</a> (<a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *root)</td></tr>
<tr class="memdesc:af59e458ea6b4d9ab6ceadfb0213f5f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a list of all entities in an entity tree to the console.  <a href="#af59e458ea6b4d9ab6ceadfb0213f5f49">More...</a><br /></td></tr>
<tr class="separator:af59e458ea6b4d9ab6ceadfb0213f5f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a612ac89ae22a8cdec8b975173b5eeb5c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a612ac89ae22a8cdec8b975173b5eeb5c">initSceneManager</a> ()</td></tr>
<tr class="memdesc:a612ac89ae22a8cdec8b975173b5eeb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the scene manager.  <a href="#a612ac89ae22a8cdec8b975173b5eeb5c">More...</a><br /></td></tr>
<tr class="separator:a612ac89ae22a8cdec8b975173b5eeb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8871bfddf3e3f7497fcdf1b680dc0e48"><td class="memItemLeft" align="right" valign="top"><a id="a8871bfddf3e3f7497fcdf1b680dc0e48"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a8871bfddf3e3f7497fcdf1b680dc0e48">closeSceneManager</a> ()</td></tr>
<tr class="memdesc:a8871bfddf3e3f7497fcdf1b680dc0e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close down the scene manager and delete all its assets. <br /></td></tr>
<tr class="separator:a8871bfddf3e3f7497fcdf1b680dc0e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219b7bccb70db3400ec513839c97e958"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a219b7bccb70db3400ec513839c97e958">copyAiNodes</a> (const aiScene *pScene, std::vector&lt; <a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> * &gt; &amp;meshes, std::vector&lt; <a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> * &gt; &amp;materials, aiNode *node, <a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *parent)</td></tr>
<tr class="memdesc:a219b7bccb70db3400ec513839c97e958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Follow the Assimp tree of nodes and create entities from them.  <a href="#a219b7bccb70db3400ec513839c97e958">More...</a><br /></td></tr>
<tr class="separator:a219b7bccb70db3400ec513839c97e958"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a83355400bed0580ec493733a720a4e9a"><td class="memItemLeft" align="right" valign="top"><a id="a83355400bed0580ec493733a720a4e9a"></a>
std::map&lt; std::string, <a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a83355400bed0580ec493733a720a4e9a">m_meshes</a> = {}</td></tr>
<tr class="memdesc:a83355400bed0580ec493733a720a4e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage of all meshes currently in the engine. <br /></td></tr>
<tr class="separator:a83355400bed0580ec493733a720a4e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9181d84127dae4c7d304fc40577e86c"><td class="memItemLeft" align="right" valign="top"><a id="aa9181d84127dae4c7d304fc40577e86c"></a>
std::map&lt; std::string, <a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#aa9181d84127dae4c7d304fc40577e86c">m_materials</a> = {}</td></tr>
<tr class="memdesc:aa9181d84127dae4c7d304fc40577e86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage of all materials currently in the engine. <br /></td></tr>
<tr class="separator:aa9181d84127dae4c7d304fc40577e86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeedb9ee5317fcf9dcdca724dcb86b2b"><td class="memItemLeft" align="right" valign="top"><a id="aaeedb9ee5317fcf9dcdca724dcb86b2b"></a>
std::map&lt; std::string, <a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#aaeedb9ee5317fcf9dcdca724dcb86b2b">m_sceneNodes</a> = {}</td></tr>
<tr class="memdesc:aaeedb9ee5317fcf9dcdca724dcb86b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage of all scene nodes currently in the engine. <br /></td></tr>
<tr class="separator:aaeedb9ee5317fcf9dcdca724dcb86b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fee4d83dc3766d0e44fea509fc46e42"><td class="memItemLeft" align="right" valign="top"><a id="a2fee4d83dc3766d0e44fea509fc46e42"></a>
<a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a2fee4d83dc3766d0e44fea509fc46e42">m_rootSceneNode</a></td></tr>
<tr class="memdesc:a2fee4d83dc3766d0e44fea509fc46e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">The root node of the scene graph. <br /></td></tr>
<tr class="separator:a2fee4d83dc3766d0e44fea509fc46e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fbd394a2d6ff4797ecff2921d6cbcb"><td class="memItemLeft" align="right" valign="top"><a id="ae3fbd394a2d6ff4797ecff2921d6cbcb"></a>
<a class="el" href="classve_1_1_v_e_camera.html">VECamera</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#ae3fbd394a2d6ff4797ecff2921d6cbcb">m_camera</a> = nullptr</td></tr>
<tr class="memdesc:ae3fbd394a2d6ff4797ecff2921d6cbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">entity ptr of the current camera <br /></td></tr>
<tr class="separator:ae3fbd394a2d6ff4797ecff2921d6cbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9304990871bbe6cc0abd0351929439"><td class="memItemLeft" align="right" valign="top"><a id="a0c9304990871bbe6cc0abd0351929439"></a>
std::vector&lt; <a class="el" href="classve_1_1_v_e_light.html">VELight</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a0c9304990871bbe6cc0abd0351929439">m_lights</a> = {}</td></tr>
<tr class="memdesc:a0c9304990871bbe6cc0abd0351929439"><td class="mdescLeft">&#160;</td><td class="mdescRight">ptrs to the lights to use <br /></td></tr>
<tr class="separator:a0c9304990871bbe6cc0abd0351929439"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The scene Manager manages the objects that have been loaded and put into the world. </p>
<p>The scene manager can load objects from file and place them into the world. It also maintains cameras and lights. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a18a142d8ebce07b6f149fbe8fd8647df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a142d8ebce07b6f149fbe8fd8647df">&#9670;&nbsp;</a></span>addSceneNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::addSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>pNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new scene node into the scene. </p>
<p>If the parent is the nullptr then make the root scene node its parent</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pNode</td><td>Pointer to the new scene node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a219b7bccb70db3400ec513839c97e958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219b7bccb70db3400ec513839c97e958">&#9670;&nbsp;</a></span>copyAiNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::copyAiNodes </td>
          <td>(</td>
          <td class="paramtype">const aiScene *&#160;</td>
          <td class="paramname"><em>pScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>meshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>materials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">aiNode *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Follow the Assimp tree of nodes and create entities from them. </p>
<p>Assimp returns a tree of nodes, each node having one or more meshes. Since an <a class="el" href="classve_1_1_v_e_entity.html" title="Represents any object that can be drawn.">VEEntity</a> can have only one mesh, for each of the meshes one <a class="el" href="classve_1_1_v_e_entity.html" title="Represents any object that can be drawn.">VEEntity</a> is created and being made the child of the current parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pScene</td><td>A pointer to the Assimp scene </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshes</td><td>The meshes that were loaded by Assimp from the file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">materials</td><td>The materials that were loaded by Assimp from the file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>The Assimp node currently being processed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>The parent entity of the new entity </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a05a9c4236e5aa2a2140f172bd4f6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a05a9c4236e5aa2a2140f172bd4f6b1">&#9670;&nbsp;</a></span>createCubemap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> * ve::VESceneManager::createCubemap </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>entityName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>basedir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a cube map based sky box. </p>
<p>This function uses GLI to load either a ktx or dds file containing a cube map. The cube is then rotated an scaled so that it can be used as sky box.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entityName</td><td>Name of the new entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basedir</td><td>Name of the directory the texture file is in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of the texture file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new entity </dd></dl>

</div>
</div>
<a id="a22900dda5097a091f671992599a5a826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22900dda5097a091f671992599a5a826">&#9670;&nbsp;</a></span>createCubemap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> * ve::VESceneManager::createCubemap </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>entityName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>basedir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>filenames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a cube map based sky box. </p>
<p>This function loads 6 textures to use them in a cube map. The cube is then rotated an scaled so that it can be used as sky box.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entityName</td><td>Name of the new entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basedir</td><td>Name of the directory the texture file is in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filenames</td><td>List of 6 names of the texture files. Order must be ft bk up dn rt lf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new entity </dd></dl>

</div>
</div>
<a id="a11d07f4374b091bffc885f272ac1bf5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d07f4374b091bffc885f272ac1bf5f">&#9670;&nbsp;</a></span>createEntity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_entity.html">VEEntity</a> * ve::VESceneManager::createEntity </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>entityName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> *&#160;</td>
          <td class="paramname"><em>pMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> *&#160;</td>
          <td class="paramname"><em>pMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::mat4&#160;</td>
          <td class="paramname"><em>transf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entityName</td><td>The name of the new entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pMesh</td><td>Pointer the mesh for this entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pMat</td><td>Pointer to the material for this entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transf</td><td>Local to parent transform, given as GLM matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Pointer to entity to be used as parent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new entity </dd></dl>

</div>
</div>
<a id="a9e9773c6d25c6fa5ea849fe393bb8e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9773c6d25c6fa5ea849fe393bb8e7b">&#9670;&nbsp;</a></span>createEntity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_entity.html">VEEntity</a> * ve::VESceneManager::createEntity </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>entityName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_entity.html#a2c7f15fd3b11aac4dea3e76cfa508010">VEEntity::veEntityType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> *&#160;</td>
          <td class="paramname"><em>pMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> *&#160;</td>
          <td class="paramname"><em>pMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::mat4&#160;</td>
          <td class="paramname"><em>transf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entityName</td><td>The name of the new entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The entity type to be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pMesh</td><td>Pointer the mesh for this entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pMat</td><td>Pointer to the material for this entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transf</td><td>Local to parent transform, given as GLM matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Pointer to entity to be used as parent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new entity </dd></dl>

</div>
</div>
<a id="a40cb40d0509a6db4730d8204d08a8c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40cb40d0509a6db4730d8204d08a8c12">&#9670;&nbsp;</a></span>createMaterials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::createMaterials </td>
          <td>(</td>
          <td class="paramtype">const aiScene *&#160;</td>
          <td class="paramname"><em>pScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>basedir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filekey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>materials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create all <a class="el" href="classve_1_1_v_e_material.html" title="Store material data.">VEMaterial</a> instances from a file loaded by Assimp. </p>
<p>Once Assimp loaded a file it offers a global list of materials. The function just goes through this list and creates <a class="el" href="classve_1_1_v_e_material.html" title="Store material data.">VEMaterial</a> instances, then stores pointers to the in the materials list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pScene</td><td>Pointer to the Assimp scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basedir</td><td>Name of the directory the file is in (for loading textures) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filekey</td><td>Unique string identifying this file. Can be used for the mesh names. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">materials</td><td>List of new materials. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0dffe81f507aafc98ce88bde78f7c61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dffe81f507aafc98ce88bde78f7c61a">&#9670;&nbsp;</a></span>createMeshes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::createMeshes </td>
          <td>(</td>
          <td class="paramtype">const aiScene *&#160;</td>
          <td class="paramname"><em>pScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filekey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>meshes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create all <a class="el" href="classve_1_1_v_e_mesh.html" title="Store a mesh in a Vulkan vertex and index buffer.">VEMesh</a> instances from a file loaded by Assimp. </p>
<p>Once Assimp loaded a file it offers a global list of meshes. The function just goes through this list and creates <a class="el" href="classve_1_1_v_e_mesh.html" title="Store a mesh in a Vulkan vertex and index buffer.">VEMesh</a> instances, then stores pointers to the in the meshes list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pScene</td><td>Pointer to the Assimp scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filekey</td><td>Unique string identifying this file. Can be used for the mesh names. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">meshes</td><td>List of new meshes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a360348074bc1b7258ebac56c427c52c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360348074bc1b7258ebac56c427c52c3">&#9670;&nbsp;</a></span>createSceneNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> * ve::VESceneManager::createSceneNode </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>objectName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::mat4&#160;</td>
          <td class="paramname"><em>transf</em> = <code>glm::mat4(1.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a scene node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">objectName</td><td>The name of the new MO. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transf</td><td>Local to parent transform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Pointer to entity to be used as parent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new scene node </dd></dl>

</div>
</div>
<a id="af429201487fd4e085080ed3fc839a8ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af429201487fd4e085080ed3fc839a8ea">&#9670;&nbsp;</a></span>createSceneNodeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::createSceneNodeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>pObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>namelist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a list of all child entities of a given entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pObject</td><td>Pointer to the root of the tree. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">namelist</td><td>List of names of children of the entity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae47277fd521d322ee02dc51f643e7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae47277fd521d322ee02dc51f643e7f8">&#9670;&nbsp;</a></span>createSkybox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> * ve::VESceneManager::createSkybox </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>entityName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>basedir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>texNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a skyplane based sky box. </p>
<p>This function loads 5 textures to use them as sky planes. The bottom plane is not loaded The order of the tex names must be ft bk up dn rt lf</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entityName</td><td>Name of the new entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basedir</td><td>Name of the directory the texture file is in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">texNames</td><td>List of 6 names of the texture files. Order must be ft bk up dn rt lf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new entity, which is the parent of the planes </dd></dl>

</div>
</div>
<a id="a733b1cdeac84abc64ede58ac22d61021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733b1cdeac84abc64ede58ac22d61021">&#9670;&nbsp;</a></span>createSkyplane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_entity.html">VEEntity</a> * ve::VESceneManager::createSkyplane </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>entityName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>basedir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>texName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a plane that is projected to the far plane of the frustum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entityName</td><td>Name of the new entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basedir</td><td>Name of the directory the texture file is in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">texName</td><td>name of a texture file that contains the sky texture </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new entity </dd></dl>

</div>
</div>
<a id="a16ca7fe353361e0da3ee4a850f57d3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ca7fe353361e0da3ee4a850f57d3ce">&#9670;&nbsp;</a></span>deleteMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::deleteMaterial </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a material given its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the material. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88ecc663dc2570d4c54b2e36529deb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ecc663dc2570d4c54b2e36529deb5c">&#9670;&nbsp;</a></span>deleteMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::deleteMesh </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a mesh given its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4964068bea04034d723881b7551dd597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4964068bea04034d723881b7551dd597">&#9670;&nbsp;</a></span>deleteSceneNodeAndChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::deleteSceneNodeAndChildren </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an entity and all its subentities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the entity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6dedc85430da2d06259704f47ec4f3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dedc85430da2d06259704f47ec4f3c7">&#9670;&nbsp;</a></span>getCamera()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_camera.html">VECamera</a>* ve::VESceneManager::getCamera </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pointer to the current camera </dd></dl>

</div>
</div>
<a id="ad5e8d10dcab7cce48b9b5c28acda0ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e8d10dcab7cce48b9b5c28acda0ead">&#9670;&nbsp;</a></span>getLights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classve_1_1_v_e_light.html">VELight</a>*&gt;&amp; ve::VESceneManager::getLights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list with names of the current lights shining on the scene </dd></dl>

</div>
</div>
<a id="a08774600d83d1e2cdecdc2ca1bafc6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08774600d83d1e2cdecdc2ca1bafc6de">&#9670;&nbsp;</a></span>getMaterial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a>* ve::VESceneManager::getMaterial </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a material by its name and return a pointer to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of material </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a material given its name </dd></dl>

</div>
</div>
<a id="a78127a3b00123f8a108c4eeda09cc1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78127a3b00123f8a108c4eeda09cc1f8">&#9670;&nbsp;</a></span>getMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a>* ve::VESceneManager::getMesh </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a mesh by its name and return a pointer to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a mesh given its name </dd></dl>

</div>
</div>
<a id="a0f1d754eb2b772fdd7d1fc7bc8d94625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1d754eb2b772fdd7d1fc7bc8d94625">&#9670;&nbsp;</a></span>getRootSceneNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a>* ve::VESceneManager::getRootSceneNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the root scene node </dd></dl>

</div>
</div>
<a id="a22dd9760111ca205cf97b2fdcfdbb6d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22dd9760111ca205cf97b2fdcfdbb6d7">&#9670;&nbsp;</a></span>getSceneNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> * ve::VESceneManager::getSceneNode </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an entity using its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the entity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the entity </dd></dl>

</div>
</div>
<a id="a612ac89ae22a8cdec8b975173b5eeb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612ac89ae22a8cdec8b975173b5eeb5c">&#9670;&nbsp;</a></span>initSceneManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::initSceneManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the scene manager. </p>
<p>In this function the scene manager loads standard shapes like cubes and planes. Then it creates a standard camera system (camera + parent) and a standard light. </p>

</div>
</div>
<a id="afb42fdaf90df123a6fa6364191d0656b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb42fdaf90df123a6fa6364191d0656b">&#9670;&nbsp;</a></span>loadAssets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const aiScene * ve::VESceneManager::loadAssets </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>basedir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aiFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>meshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>materials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load assets from file ussing Assimp. </p>
<p>The scene manager loads assets from a file and creates the contained meshes and materials. It does not create entities. Meshes and materials are stored in the scene manager's member variables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">basedir</td><td>Name of directory the file is in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of the file containing the assets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aiFlags</td><td>Import flags for Assimp, see code below for some examples </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">meshes</td><td>A list containing pointers to the loaded meshes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">materials</td><td>A list of pointers to the loaded materials </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92f329338bd5b87cbdacf86264179b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f329338bd5b87cbdacf86264179b96">&#9670;&nbsp;</a></span>loadModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> * ve::VESceneManager::loadModel </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>entityName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>basedir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aiFlags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load assets from file ussing Assimp, create entities from them. </p>
<p>The scene manager loads assets from a file and creates the contained meshes and materials. Meshes and materials are stored in the scene manager's member variables. It then followsa the entity tree recursively and creates the contained entities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entityName</td><td>The name of the new entity (its the parent of all created entities) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basedir</td><td>Name of directory the file is in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of the file containing the assets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aiFlags</td><td>Import flags for Assimp, see code below for some examples </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Make the new entity a child of this parent entity </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af59e458ea6b4d9ab6ceadfb0213f5f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59e458ea6b4d9ab6ceadfb0213f5f49">&#9670;&nbsp;</a></span>printTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::printTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a list of all entities in an entity tree to the console. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">root</td><td>Pointer to the root entity of the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acedf235e65ee027a0df5dc92163fcefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acedf235e65ee027a0df5dc92163fcefe">&#9670;&nbsp;</a></span>setCamera()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::setCamera </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_camera.html">VECamera</a> *&#160;</td>
          <td class="paramname"><em>cam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the the current camera. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cam</td><td>Pointer to the camera </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d225517b9db68a1d93769bf72fb5e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d225517b9db68a1d93769bf72fb5e7b">&#9670;&nbsp;</a></span>switchOffLight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::switchOffLight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_light.html">VELight</a> *&#160;</td>
          <td class="paramname"><em>light</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a light from the m_lights list, thus switching it off. </p>
<p>Removing this light does not remove it from the m_entities list. Removing it from the m_lights list causes the light to be switched off.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">light</td><td>A pointer to the light to switch off </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c5a46bc9fb0c998451b96b68dcbf45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5a46bc9fb0c998451b96b68dcbf45d">&#9670;&nbsp;</a></span>switchOnLight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::switchOnLight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_light.html">VELight</a> *&#160;</td>
          <td class="paramname"><em>light</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a light to the m_lights list, thus switching it on. </p>
<p>A light must be also on the stage as entity in the scene manager's entity list. but until it is member of this list, it will not be considered as a shining light.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">light</td><td>A pointer to the light to add to the shining lights </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaadccc0f574cd30019e940ab56acc832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaadccc0f574cd30019e940ab56acc832">&#9670;&nbsp;</a></span>updateSceneNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::updateSceneNodes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>imageIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all scene nodes without a parent, then update them and their children. </p>
<p>Makes this nodes and their children to copy their data to the GPU</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">imageIndex</td><td>Index of the swapchain image that is currently used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_v_e_scene_manager_8h_source.html">VESceneManager.h</a></li>
<li>VESceneManager.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 2 2019 13:22:23 for Vienna Vulkan Engine by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
