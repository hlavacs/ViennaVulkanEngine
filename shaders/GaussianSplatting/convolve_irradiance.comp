// ============================================================================
// DISCLAIMER:
// The referenced implementation has been adapted with the assistance of generative AI.
// ============================================================================

#version 460 core

/**
 * @file convolve_irradiance.comp
 * @brief Diffuse irradiance convolution from environment cubemap
 *
 * Adapted from LearnOpenGL PBR IBL tutorial:
 * https://learnopengl.com/PBR/IBL/Diffuse-irradiance
 *
 * ============================================================================
 * COMPARISON WITH LEARNOPENGL IMPLEMENTATION
 * ============================================================================
 *
 * SIMILARITIES:
 * - Hemisphere sampling with nested phi/theta loops (Riemann sum)
 * - Same sampleDelta step size (0.025)
 * - Spherical-to-Cartesian conversion: sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)
 * - TBN matrix construction for tangent-to-world transformation
 * - Cosine-weighted integration: envSample * cos(theta) * sin(theta)
 *   - cos(theta): Lambert's cosine law (BRDF)
 *   - sin(theta): Jacobian for spherical integration (solid angle dω = sin(θ)dθdφ)
 * - Final normalization: PI * irradiance / nrSamples
 *
 * DIFFERENCES:
 * - Theta range: VVE uses 0.125*PI (22.5°) vs LearnOpenGL's 0.5*PI (90°)
 *   Reason: Tighter sampling cone preserves more detail from gaussian environments,
 *   which often have high-frequency features unlike typical HDR skyboxes.
 * - TBN singularity handling: VVE checks abs(normal.y) < 0.999 to avoid degenerate
 *   cross product when normal points straight up/down. LearnOpenGL omits this check.
 * - Execution model: VVE uses compute shader with explicit workgroup dispatch (8x8)
 *   over all 6 faces. LearnOpenGL uses fragment shader with GPU rasterization.
 * - Output: VVE uses imageStore to imageCube, LearnOpenGL renders to FBO attachment.
 *
 * ============================================================================
 *
 * For each output texel (representing a normal direction):
 * - Sample environment cubemap over hemisphere around normal
 * - Apply cosine-weighted integration (Lambert BRDF)
 * - Store averaged result in irradiance map
 */

layout(local_size_x = 8, local_size_y = 8) in;

// Input: Environment cubemap (rendered from gaussians)
layout(set = 0, binding = 0) uniform samplerCube envCubemap;

// Output: Irradiance cubemap (diffuse IBL)
layout(set = 0, binding = 1, rgba16f) uniform imageCube irradianceMap;

const float PI = 3.14159265359;

/**
 * @brief Convert cubemap face/UV to world-space direction vector
 * @param face Cubemap face index (0-5: +X, -X, +Y, -Y, +Z, -Z)
 * @param uv Texture coordinates [0,1]
 * @return Normalized direction vector
 */
vec3 getCubemapDirection(uint face, vec2 uv) {
    // Convert UV [0,1] to [-1,1]
    vec2 ndc = uv * 2.0 - 1.0;

    vec3 dir;
    if (face == 0) {        // +X
        dir = vec3(1.0, -ndc.y, -ndc.x);
    } else if (face == 1) { // -X
        dir = vec3(-1.0, -ndc.y, ndc.x);
    } else if (face == 2) { // +Y
        dir = vec3(ndc.x, 1.0, ndc.y);
    } else if (face == 3) { // -Y
        dir = vec3(ndc.x, -1.0, -ndc.y);
    } else if (face == 4) { // +Z
        dir = vec3(ndc.x, -ndc.y, 1.0);
    } else {                // -Z
        dir = vec3(-ndc.x, -ndc.y, -1.0);
    }

    return normalize(dir);
}

void main() {
    ivec3 texCoord = ivec3(gl_GlobalInvocationID);
    ivec2 imageSize = imageSize(irradianceMap);

    // Check bounds (each face is imageSize.x × imageSize.y)
    if (texCoord.x >= imageSize.x || texCoord.y >= imageSize.y || texCoord.z >= 6) {
        return;
    }

    // Get direction for this output texel (normal direction)
    vec2 uv = (vec2(texCoord.xy) + 0.5) / vec2(imageSize);
    vec3 normal = getCubemapDirection(texCoord.z, uv);

    // Construct TBN matrix for hemisphere sampling
    vec3 up = abs(normal.y) < 0.999 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangent = normalize(cross(up, normal));
    vec3 bitangent = cross(normal, tangent);
    mat3 TBN = mat3(tangent, bitangent, normal);

    // Convolve: Sample environment cubemap over hemisphere
    // Using Riemann sum approximation with fixed sample count
    vec3 irradiance = vec3(0.0);
    float sampleDelta = 0.025;  // Sample step size (smaller = more accurate, slower)
    float nrSamples = 0.0;

    for (float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta) {
        for (float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta) {  // Change to 0.125 * PI for tight cone (22.5°) for minimal blur
            // Spherical to cartesian (in tangent space)
            vec3 tangentSample = vec3(
                sin(theta) * cos(phi),
                sin(theta) * sin(phi),
                cos(theta)
            );

            // Transform to world space
            vec3 sampleDir = TBN * tangentSample;

            // Sample environment cubemap
            vec3 envSample = texture(envCubemap, sampleDir).rgb;

            // Cosine-weighted integration (Lambert BRDF: cos(theta) / PI)
            // cos(theta) = dot(normal, sampleDir) = tangentSample.z
            irradiance += envSample * cos(theta) * sin(theta);
            nrSamples += 1.0;
        }
    }

    // Normalize by sample count and PI (from integral)
    irradiance = PI * irradiance / nrSamples;

    // Write to output irradiance cubemap
    imageStore(irradianceMap, texCoord, vec4(irradiance, 1.0));
}
