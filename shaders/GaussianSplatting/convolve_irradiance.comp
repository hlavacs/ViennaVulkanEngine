#version 460 core

/**
 * @file convolve_irradiance.comp
 * @brief Diffuse irradiance convolution from environment cubemap
 *
 * Adapted from LearnOpenGL PBR IBL tutorial:
 * https://learnopengl.com/PBR/IBL/Diffuse-irradiance
 *
 * For each output texel (representing a normal direction):
 * - Sample environment cubemap over hemisphere around normal
 * - Apply cosine-weighted integration (Lambert BRDF)
 * - Store averaged result in irradiance map
 */

layout(local_size_x = 8, local_size_y = 8) in;

// Input: Environment cubemap (rendered from gaussians)
layout(set = 0, binding = 0) uniform samplerCube envCubemap;

// Output: Irradiance cubemap (diffuse IBL)
layout(set = 0, binding = 1, rgba16f) uniform imageCube irradianceMap;

const float PI = 3.14159265359;

/**
 * @brief Convert cubemap face/UV to world-space direction vector
 * @param face Cubemap face index (0-5: +X, -X, +Y, -Y, +Z, -Z)
 * @param uv Texture coordinates [0,1]
 * @return Normalized direction vector
 */
vec3 getCubemapDirection(uint face, vec2 uv) {
    // Convert UV [0,1] to [-1,1]
    vec2 ndc = uv * 2.0 - 1.0;

    vec3 dir;
    if (face == 0) {        // +X
        dir = vec3(1.0, -ndc.y, -ndc.x);
    } else if (face == 1) { // -X
        dir = vec3(-1.0, -ndc.y, ndc.x);
    } else if (face == 2) { // +Y
        dir = vec3(ndc.x, 1.0, ndc.y);
    } else if (face == 3) { // -Y
        dir = vec3(ndc.x, -1.0, -ndc.y);
    } else if (face == 4) { // +Z
        dir = vec3(ndc.x, -ndc.y, 1.0);
    } else {                // -Z
        dir = vec3(-ndc.x, -ndc.y, -1.0);
    }

    return normalize(dir);
}

void main() {
    ivec3 texCoord = ivec3(gl_GlobalInvocationID);
    ivec2 imageSize = imageSize(irradianceMap);

    // Check bounds (each face is imageSize.x × imageSize.y)
    if (texCoord.x >= imageSize.x || texCoord.y >= imageSize.y || texCoord.z >= 6) {
        return;
    }

    // Get direction for this output texel (normal direction)
    vec2 uv = (vec2(texCoord.xy) + 0.5) / vec2(imageSize);
    vec3 normal = getCubemapDirection(texCoord.z, uv);

    // Construct TBN matrix for hemisphere sampling
    vec3 up = abs(normal.y) < 0.999 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangent = normalize(cross(up, normal));
    vec3 bitangent = cross(normal, tangent);
    mat3 TBN = mat3(tangent, bitangent, normal);

    // Convolve: Sample environment cubemap over hemisphere
    // Using Riemann sum approximation with fixed sample count
    vec3 irradiance = vec3(0.0);
    float sampleDelta = 0.025;  // Sample step size (smaller = more accurate, slower)
    float nrSamples = 0.0;

    for (float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta) {
        for (float theta = 0.0; theta < 0.125 * PI; theta += sampleDelta) {  // Tight cone (22.5°) for minimal blur
            // Spherical to cartesian (in tangent space)
            vec3 tangentSample = vec3(
                sin(theta) * cos(phi),
                sin(theta) * sin(phi),
                cos(theta)
            );

            // Transform to world space
            vec3 sampleDir = TBN * tangentSample;

            // Sample environment cubemap
            vec3 envSample = texture(envCubemap, sampleDir).rgb;

            // Cosine-weighted integration (Lambert BRDF: cos(theta) / PI)
            // cos(theta) = dot(normal, sampleDir) = tangentSample.z
            irradiance += envSample * cos(theta) * sin(theta);
            nrSamples += 1.0;
        }
    }

    // Normalize by sample count and PI (from integral)
    irradiance = PI * irradiance / nrSamples;

    // Write to output irradiance cubemap
    imageStore(irradianceMap, texCoord, vec4(irradiance, 1.0));
}
